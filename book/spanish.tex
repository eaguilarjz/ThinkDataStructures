\documentclass[12pt]{book}

\title{Piensa en Estructuras de Datos}
\author{Allen B. Downey}

\renewcommand{\contentsname}{Contenidos}% E. Aguilar, 20190611
\renewcommand{\chaptername}{Capítulo}% E. Aguilar, 20190611
\renewcommand{\figurename}{Figura}% E. Aguilar, 20190612
\renewcommand{\indexname}{Índice}

\newcommand{\thetitle}{Piensa en Estructuras de Datos}
\newcommand{\thesubtitle}{Algoritmos y Recuperación de Información en Java}
\newcommand{\theauthors}{Allen B. Downey}
\newcommand{\theversion}{1.0.1}

%%%% Both LATEX and PLASTEX

\usepackage{graphicx}
\usepackage{hevea}
\usepackage{makeidx}
\usepackage{setspace}
%\usepackage{longtable}
\usepackage{booktabs}

%\usepackage{draftwatermark}
%\SetWatermarkText{DRAFT: Not ready for distribution!}
%\SetWatermarkScale{1}

\makeindex

% automatically index glossary terms
\newcommand{\term}[1]{%
\item[#1:]\index{#1}}

\usepackage{amsmath}
\usepackage{amsthm}

% format end of chapter exercises
\newtheoremstyle{exercise}
  {12pt}        % space above
  {12pt}        % space below
  {}            % body font
  {}            % indent amount
  {\bfseries}   % head font
  {}            % punctuation
  {12pt}        % head space
  {}            % custom head
\theoremstyle{exercise}
\newtheorem{exercise}{Exercise}[chapter]

\newif\ifplastex
\plastexfalse

%%%% PLASTEX ONLY
\ifplastex

\usepackage{localdef}

\usepackage{url}

\newcount\anchorcnt
\newcommand*{\Anchor}[1]{%
  \@bsphack%
    \Hy@GlobalStepCount\anchorcnt%
    \edef\@currentHref{anchor.\the\anchorcnt}%
    \Hy@raisedlink{\hyper@anchorstart{\@currentHref}\hyper@anchorend}%
    \M@gettitle{}\label{#1}%
    \@esphack%
}

% code listing environments:
% we don't need these for plastex because they get replaced
% by preprocess.py
%\newenvironment{code}{\begin{verbatim}}{\end{verbatim}}
%\newenvironment{stdout}{\begin{verbatim}}{\end{verbatim}}

% inline syntax formatting
%\newcommand{\java}{\verb}%}

%%%% LATEX ONLY
\else

\input{latexonly}

\fi

%%%% END OF PREAMBLE
\begin{document}

\frontmatter

%%%% PLASTEX ONLY
\ifplastex

\maketitle

%%%% LATEX ONLY
\else

\begin{latexonly}

%--half title-------------------------------------------------
\thispagestyle{empty}

\begin{flushright}
\vspace*{2.0in}

\begin{spacing}{3}
{\huge \thetitle} \\
{\Large \thesubtitle}
\end{spacing}

\vspace{0.25in}

Versión \theversion

\vfill
\end{flushright}

%--verso------------------------------------------------------
\newpage
\thispagestyle{empty}

\quad

%--title page-------------------------------------------------
\newpage
\thispagestyle{empty}

\begin{flushright}
\vspace*{2.0in}

\begin{spacing}{3}
{\huge \thetitle} \\
{\Large \thesubtitle}
\end{spacing}

\vspace{0.25in}

Versión \theversion

\vspace{1in}

{\Large \theauthors}

{\small Traducido por: Ernesto A. Aguilar}

\vspace{0.5in}

{\Large Green Tea Press}

{\small Needham, Massachusetts}

\vfill
\end{flushright}

%--copyright--------------------------------------------------
\newpage
\thispagestyle{empty}

Copyright \copyright ~2016 \theauthors.

\vspace{0.2in}

\begin{flushleft}
Green Tea Press \\
9 Washburn Ave \\
Needham, MA 02492
\end{flushleft}

Se permite copiar, distribuir, y/o modificar este documento
bajo los términos de la Creative Commons
Attribution-NonCommercial-ShareAlike 3.0 Unported License,
disponible en \url{http://thinkdast.com/cc30}.

El formato original de este libro es código fuente \LaTeX\ . La compilación de este
código tiene el efecto de generar una representación del libro independiente del
dispositivo, que puede convertirse a otros formatos e imprimirse.

El fuente \LaTeX\ de este libro está disponible en
\url{http://thinkdast.com/repo}.

%--table of contents------------------------------------------

\cleardoublepage
\setcounter{tocdepth}{1}
\tableofcontents

\end{latexonly}

%--HTML title page--------------------------------------------

\begin{htmlonly}

\vspace{1em}

{\Large \thetitle: \thesubtitle}

{\large \theauthors}

Versión \theversion

\vspace{1em}

Copyright \copyright ~2016 \theauthors.

Permission is granted to copy, distribute, and/or modify this work
under the terms of the Creative Commons
Attribution-NonCommercial-ShareAlike 3.0 Unported License, which is
available at \url{http://thinkdast.com/cc30}.

\vspace{1em}

\end{htmlonly}

%-------------------------------------------------------------

% END OF THE PART WE SKIP FOR PLASTEX
\fi


\chapter*{Prefacio}
\label{preface}

\markboth{PREFACIO}{PREFACIO}
\addcontentsline{toc}{chapter}{Prefacio}


\section*{La filosofía tras este libro}

Las estructuras de datos y los algoritmos están entre las invenciones más importantes
de los últimos 50 años, y son herramientas fundamentales que los ingenieros de
software necesitan conocer. Pero en mi opinión, la mayoría de los libros sobre
el tema son muy teóricos, muy grandes y muy ``detallados'':

\begin{description}

\item[Muy teóricos]  El análisis matemático de los algoritmos se base en
simplificar supuestos, lo que limita su utilidad en la práctica.
La mayoría de exposiciones sobre el tema apenas cubren las simplificaciones y
se enfocan en la matemática. En este libro presento el subconjunto más práctico
de este material y omito o enfatizo menos el resto.

\item[Muy grandes] La mayoría de libros sobre el tema tienen al menos 500 páginas,
y algunos más de 1000. Al enfocarme en los temas que considero más útiles
para los ingenieros de software, mantuve este libro por debajo de las 200 páginas.

\item[Muy ``detallados''] Muchos libros de estructuras de datos se enfocan más 
en cómo funcionan las estructuras de datos (las implementaciones) y menos
en cómo usarlas (las interfaces). En este libro, proveo una ``visión general'',
al iniciar con las interfaces. Los lectores aprenderán a usar las estructuras del
Java Collections Framework antes de adentrarse en los detalles de cómo funcionan.

\end{description}

Finalmente, algunos libros presentan este material fuera de contexto y sin
motivación alguna: ¡es sólo una estructura de datos tras otra!
Trato de volverlo más ameno al organizar los temas alrededor de una
aplicación -- la búsqueda web -- que usa estructuras de datos
ampliamente, y es una tema interesante e importante por sus propios méritos.

\index{búsqueda web}

Esta aplicación motiva algunos temas que generalmente no se cubren
en una curso introductorio de estructuras de datos, incluyendo estructuras
de datos persistentes con Redis.

\index{Redis}

He tomado algunas decisiones difíciles con relación a qué dejar fuera,
pero he hecho algunas concesiones. Incluyo algunos temas que la
mayoría de los lectores nunca usarán, pero que podría esperarse
que conozcan, posiblemente en una entrevista técnica. Para estos
temas, presento tanto la sabiduría convencional como mis razones
para ser escéptico al respecto.

Este libro también presenta aspectos básicos de la ingeniería de software
en la práctica, incluyendo control de versiones y pruebas unitarias. La mayoría
de los capítulos incluyen un ejercicio que permite a los lectores aplicar lo
que han aprendido. Cada ejercicio provee pruebas automáticas para comprobar
la solución. Y para la mayoría de ejercicios, presento mi solución al principio
del siguiente capítulo.

\index{pruebas unitarias}
\index{control de versiones}


\section{Prerrequisitos}
\label{prerequisites}

Este libro está dirigido a estudiantes de ciencias de la computación
y ramas afines, así como a ingenieros de software profesionales,
personas capacitándose en ingeniería de software y personas
personas preparándose para entrevistas técnicas.

Antes de comenzar este libro, deberías conocer Java bastante bien;
en particular, deberías saber como definir una nueva clase que extienda
una clase existente o implemente una \java{interface}. Si tu Java está
oxidado, aquí están dos libros con los que podrías empezar:

\begin{itemize}

\item Downey and Mayfield, {\it Think Java} (O'Reilly Media, 2016, en inglés),
pensado para personas que nunca antes han programado.

\item Sierra and Bates, {\it Head First Java} (O'Reilly Media, 2005, en inglés),
apropiado para personas que ya conocen otro lenguaje de programación.

\end{itemize}

Si no estás familiarizado con las interfaces en Java, podrías revisar
el tutorial llamado ``What Is an Interface?'' en
\url{http://thinkdast.com/interface}.

\index{interfaz}
\index{interface}

Una nota de vocabulario: la palabra ``interfaz'' (o ``interface'', en inglés) puede resultar
confusa. En el contexto de una {\bf interfaz de programación de aplicaciones} (API, de 
{\bf application programming interface}), se refiere a un conjunto de clases y métodos
que proveen ciertas funcionalidades.

\index{interfaz de programación de aplicaciones}
\index{API}

En el caso de Java, también se refiere a una característica del lenguaje,
similar a una clase, que especifica un conjunto de métodos. Para evitar
confusiones, usaré ``interfaz'' en un tipo de fuente normal y en español, para la
idea general de una interfaz, e \java{interface} en una fuente monoespaciada y en inglés,
para la característica del lenguaje Java.

También deberías estar familiarizado con los parámetros de tipo y los tipos genéricos.
Por ejemplo, deberías saber cómo crear un objeto con un parámetro de tipo, 
como \java{ArrayList<Integer>}.  Si no, puedes leer sobre los parámetros de tipo
en \url{http://thinkdast.com/types}.

\index{type parameter}

Deberías estar familiarizado con el Java Collections Framework
(JCF), sobre el que puedes leer en
\url{http://thinkdast.com/collections}.
En particular, deberías conocer la \java{interface} \java{List}
y las clases \java{ArrayList} y \java{LinkedList}.

\index{Java Collections Framework}
\index{JCF}

Idealmente deberías estar familiarizado con Apache Ant, una herramienta automatizada de
de construcción para Java.  Puedes leer más sobre Ant en \url{http://thinkdast.com/anttut}.

\index{Apache Ant}
\index{Ant}

Y deberías estar familiarizado con {\tt JUnit}, un \textit{framework} para Java. Puedes
leer más sobre él en \url{http://thinkdast.com/junit}.

\index{JUnit}


\section*{Trabajando con el código}
\label{code}

El código para este libro está en un repositorio de Git en
\url{http://thinkdast.com/repo}.

\index{Git}
\index{control de versiones}

Git es un ``sistema de control de versiones'' que te permite dar seguimiento a los
archivos que conforman un proyecto. Una colección de archivos bajo el control
de Git es llamada un ``repositorio''.

\index{repositorio}
\index{GitHub}

GitHub es un servicio de alojamiento que provee almacenamiento para repositorios
de Git y una interfaz web conveniente. Provee varias formas de trabajar con el código:

\begin{itemize}

\item Puedes crear una copia del repositorio en GitHub presionando el botón {\sf Fork}. 
Si no tienes una cuenta en GitHub, necesitarás crear una. Tras crear el fork, 
tendrás tu propio repositorio en GitHub que puedes usar para dar seguimiento al código
que escribes. Luego puedes ``clonar'' (``clone'', en inglés) el repositorio, para descargar una
copia de los archivos a tu computadora.

\index{fork}
\index{clone}

\item Alternativamente, puedes clonar el repositorio sin crear un fork. Si eliges esta opción,
no necesitas una cuenta de GitHub, pero no podrás guardar tus cambios en GitHub.

\item Si no quieres usar Git en lo absoluto, puedes descargar el código en un archivo ZIP usando el
botón {\sf Download} en la página de GitHub, o este enlace: \url{http://thinkdast.com/zip}.

\end{itemize}

Después de clonar el repositorio o descomprimir el archivo ZIP, tendrás un directorio llamado {\tt ThinkDataStructures},
que es el título del libro en inglés, con un subdirectorio {\tt code}.

Los ejemplos en este libro fueron desarrollados y probados usando el Java SE
Development Kit 7.  Si estás usando una versión más antigua, algunos ejemplos
no funcionarán. Si estás usando una versión más reciente, todos deberían funcionar.

\index{Java SDK}

\section*{Colaboradores}

Este libro es una adaptación de la currícula que escribí para la
Flatiron School en New York City, que ofrece varias clases en línea
relacionadas con programación y desarrollo web. Ellos ofrecen una
clase basada en este material, que provee un entorno de desarrollo
en línea, ayuda de instructores y otros estudiantes, así como un
certificado de finalización. Puedes encontrar más información en
\url{http://flatironschool.com}.


\begin{itemize}

\item En la Flatiron School, Joe Burgess, Ann John y Charles
  Pletcher brindaron orientación, sugerencias y correcciones desde la
  especificación inicial hasta la implementación y las pruebas. ¡Muchas
  gracias a todos ustedes!

\item Estoy muy agradecido con mis revisores técnicos, Barry Whitman,
  Patrick White y Chris Mayfield, que dieron muchas sugerencias útiles
  y detectaron muchos errores. Por supuesto, ¡cualquier error restante
  es mi responsabilidad, no la de ellos!

\item Gracias a los instructores y estudiantes de Estructuras de Datos y
  Algoritmos en Olin College, que leyeron este libro y brindaron realimentación
  útil.

\item Charles Roumeliotis editó y corrigió el libro para O'Reilly Media
y realizó muchas mejoras.

% ENDCONTRIB

\end{itemize}


% Additional contributors who found one or more typos: coming soon, I'm sure.

Si tienes comentarios o ideas sobre el texto, por favor envíalas a:\linebreak
{\tt feedback@greenteapress.com}.

\mainmatter

\chapter{Interfaces}
\label{cs-lists-programming-to-an-interface-readme}

Este libro presenta tres temas:

\begin{itemize}

\item Estructuras de datos: Iniciando con las estructuras en el Java
Collections Framework (JCF), aprenderás cómo usar estructuras de datos
como listas y mapas y verás cómo trabajan.

\index{estructuras de datos}

\item Análisis de algoritmos: Presento técnicas para analizar código y
predecir qué tan rápido se ejecutará y cuánto espacio (memoria) requerirá.

\index{análisis de algoritmos}

\item Recuperación de información: Para motivar el estudio de los primeros
dos temas y hacer los ejercicios más interesantes, usaremos estructuras de
datos y algoritmos para construir un motor simple de búsqueda en la web.

\index{recuperación de información}
\index{motor de búsqueda}

\end{itemize}

Aquí está una descripción general del orden de los temas:

\begin{itemize}

\item Iniciaremos con la interfaz {\tt List} y escribirás clases que
implementarán esta interfaz de dos formas diferentes. Luego, vamos a
comparar tus implementaciones con las clases de Java {\tt ArrayList} y
{\tt LinkedList}.

\index{List}
\index{ArrayList}
\index{LinkedList}

\item A continuación, introduciré tres estructuras de datos en forma de árbol, y
trabajarás en la primera aplicación: un programa que lea páginas de Wikipedia,
interprete sus contenidos y navegue por el árbol resultante para encontrar enlaces
y otras características. Usaremos estas herramientas para comprobar la conjetura
``Llegar a la Filosofía'' (puedes anticiparte leyendo \url{http://thinkdast.com/getphil}).

\index{árbol}
\index{Llegar a la Filosofía}

\item Aprenderemos sobre la interfaz {\tt Map} y la implementación
{\tt HashMap} de Java. Luego escribiremos clases que implementen
esta interfaz usando una tabla hash y un árbol binario de búsqueda.

\index{Map}
\index{HashMap}
\index{tabla hash}
\index{árbol binario de búsqueda}

\item Finalmente, usarás estas clases (y unas cuantas más que presentaré en
el camino) para implementar un motor de búsqueda en la web, incluyendo: un \textit{rastreador} que
encuentra y lee páginas, un indexador que guarda los contenidos de las páginas Web de forma que puedan
realizarse búsquedas en ellas eficientemente, y un recuperador que toma las consultas de un usuario
y devuelve resultados relevantes.

\index{búsqueda web}
\index{rastreador}
\index{indexador}
\index{recuperador}

\end{itemize}

Comencemos.


\section{¿Por qué hay dos tipos de \java{List}?}
\label{why-are-there-two-kinds-of-list}

Cuando las personas comienzan a trabajar con el Java Collections
Framework, a veces se confunden entre \java{ArrayList} y
\java{LinkedList}.  ¿Por qué Java provee dos implementaciones de
la \java{interface} \java{List}? ¿Y cómo deberías elegir cuál usar?
Responderemos estas preguntas en los siguientes capítulos.

\index{List}
\index{ArrayList}
\index{LinkedList}

Comenzaré por revisar las \java{interface}s y las clases que las
implementan y presentará la idea de ``programar para una interfaz''.

\index{interface}

En los primeros ejercicios a continuación, implementarás clases similares 
a \java{ArrayList} y \java{LinkedList}, para entender cómo funcionan
y veremos que cada una de ellas tiene pros y contras. Algunas operaciones
son más rápidas o usan menos espacio con una \java{ArrayList}; otras
son más rápidas o más pequeñas con una \java{LinkedList}.  Cuál de ellas
es mejor para una aplicación particular depende de las operaciones que
se realizan con más frecuencia.


\section{Interfaces en Java}
\label{interfaces-in-java}

Una \java{interface} de Java especifica un conjunto de métodos; cualquier clase
que implemente esta \java{interface} tiene que proveer estos métodos. Por
ejemplo, aquí está el código fuente para \java{Comparable}, que es una
\java{interface} definida en el paquete \java{java.lang}:

\index{Comparable}

\begin{verbatim}
public interface Comparable<T> {
    public int compareTo(T o);
}
\end{verbatim}

\index{tipo genérico}

Esta definición de \java{interface} usa un parámetro de tipo, \java{T}, lo que
hace a \java{Comparable} un {\bf tipo genérico}.  
Para implementar esta \java{interface}, una clase tiene que

\begin{itemize}

\item Especificar el tipo al que \java{T} se refiere y

\item Proveer un método llamado \java{compareTo} que tome un objeto como
parámetro y devuelva un \java{int}.

\end{itemize}

\index{compareTo}
\index{Integer}

Por ejemplo, aquí está el código fuente para \java{java.lang.Integer}:

\begin{verbatim}
public final class Integer extends Number implements Comparable<Integer> {

    public int compareTo(Integer anotherInteger) {
        int thisVal = this.value;
        int anotherVal = anotherInteger.value;
        return (thisVal<anotherVal ? -1 : (thisVal==anotherVal ? 0 : 1));
    }

    // otros métodos omitidos
}
\end{verbatim}

Esta clase extiende \java{Number}, por lo que hereda los métodos y
variables de instancia de \java{Number}; e implementa
\java{Comparable<Integer>}, así que provee un método con el nombre
\java{compareTo} que toma un \java{Integer} y devuelve
un \java{int}.

\index{Number}
\index{Comparable}

Cuando una clase declara que implementa una \java{interface}, el compilador
verifica que provea todos los métodos definidos por la \java{interface}.

\index{operador ternario}

Al margen, esta implementación de \java{compareTo} usa el
``operador ternario'', que a veces se escribe \java{?:}.  Si no estás
familiarizado con él, puedes leer al respecto en
\url{http://thinkdast.com/ternary}.


\section{La interfaz List}
\label{the-list-interface}

El Java Collections Framework (JCF) define una \java{interface} llamada
\java{List} y provee dos implementaciones, \java{ArrayList} y
\java{LinkedList}.

\index{List}

La \java{interface} define lo que implica ser una \java{List}; cualquier
clase que implemente esta \java{interface} tiene que proveer un
conjunto particular de métodos, que incluyen \java{add}, \java{get},
\java{remove} y alrededor de 20 más.

\java{ArrayList} y \java{LinkedList} proveen estos métodos, así que
ambas pueden ser usadas de forma intercambiable. Un método escrito
para funcionar con una \java{List} funcionará con una \java{ArrayList}, \java{LinkedList},
o cualquier otro objeto que implemente \java{List}.

\index{ArrayList}
\index{LinkedList}

Aquí está un ejemplo artificial para demostrar el punto:

\begin{verbatim}
public class ListClientExample {
    private List list;
    
    public ListClientExample() {
        list = new LinkedList();
    }

    private List getList() {
        return list;        
    }

    public static void main(String[] args) {
        ListClientExample lce = new ListClientExample();
        List list = lce.getList();
        System.out.println(list);
    }
}
\end{verbatim}

\index{ListClientExample}
\index{encapsular}

\java{ListClientExample} no hace nada útil, pero contiene los
elementos esenciales de una clase que {\bf encapsula} una
\java{List}; es decir, contiene una \java{List} como una variable
de instancia. Usaré esta clase para ilustrar un punto y luego
trabajarás con ella en el primer ejercicio.

\index{instanciar}

El constructor \java{ListClientExample} inicializa una \java{list} al
{\bf instanciar} (es decir, crear) una nueva \java{LinkedList}; el
método getter \java{getList} devuelve una referencia al objeto
interno \java{List}; y \java{main} contiene unas pocas líneas
de código para probar estos métodos.

Lo importante de este ejemplo es que usa \java{List}
cuando es posible y evita especificar \java{LinkedList} o
\java{ArrayList} a menos que sea necesario. Por ejemplo, la variable
de instancia es declarada como una \java{List} y \java{getList} devuelve
una \java{List}, pero ninguno especifica qué tipo de lista.

Si cambias de opinión y decides usar una \java{ArrayList}, solo tienes
que cambiar el constructor; no tienes que hacer ninguna modificación
adicional.

\index{programación basada en interfaces}
\index{programar para una interfaz}

Este estilo es llamado {\bf programación basada en interfaces},
o de forma más casual, ``programar para una interfaz''
(véase \url{http://thinkdast.com/interbaseprog}).
De lo que hablamos es de la idea general de una interfaz, no de
una \java{interface} de Java.

Cuando usas una biblioteca, tu código debería depender únicamente de
la interfaz, como \java{List}.  No debería depender de implementaciones
específicas, como \java{ArrayList}. De esa forma, si la implementación
cambia en el futuro, el código que la usa seguirá funcionando.

Por otro lado, si la interfaz cambia, el código que depende de ella también
tiene que cambiar. Es por eso que los desarrolladores de bibliotecas
evitan cambiar las interfaces a menos que sea absolutamente necesario.


\section{Ejercicio 1}
\label{warming-up}

Dado que este es el primer ejercicio, lo mantendremos simple. Tomarás
el código de la sección anterior e {\bf intercambiarás la implementación};
es decir, reemplazarás la \java{LinkedList} con una \java{ArrayList}.  
Debido a que el código programa para una interfaz, serás capaz de
intercambiar la implementación cambiando una sola línea de código y
agregando una instrucción \java{import}.

Comienza configurando tu entorno de desarrollo. Para todos los
ejercicios, necesitarás poder compilar y ejecutar código de Java.
Desarrollé los ejemplo usando el Java SE Development Kit 7.  Si estás
usando una versión más reciente, todo debería funcionar. Si estás
usando una versión más antigua, puede que encuentres algunas
incompatibilidades.

\index{Java SDK}
\index{entorno de desarrollo integrado}
\index{IDE}

Recomiendo usar un entorno de desarrollo integrado (IDE) que
provea comprobación de sintaxis, auto-completado y caracterización
de código fuente. Estas características te ayudan a prevenir errores o
a encontrarlos rápidamente. Sin embargo, si estás preparándote para
una entrevista técnica, recuerda que no tendrás a tu disposición estas
herramientas durante la entrevista, por lo que podrías querer practicar
escribiendo código sin ellas.

Si aun no has descargado el código para este libro, revisa las
instrucciones en la Sección~\ref{code}.

En el directorio llamado {\tt code}, encontrarás estos archivos y
directorios:

\begin{itemize}
  \item
    \java{build.xml} es un archivo Ant que facilita compilar y
    ejecutar el código.

  \item
    \java{lib} contiene las bibliotecas que necesitarás (para este
    ejercicio, solo JUnit).

  \item
    \java{src} contiene el código fuente.

\end{itemize}

Si navegas a \java{src/com/allendowney/thinkdast},
encontrarás el código fuente para este ejercicio:

\begin{itemize}

  \item
    \java{ListClientExample.java} contiene el código de la sección
    anterior.

  \item
    \java{ListClientExampleTest.java} contiene un test de JUnit para
    \java{ListClientExample}.


\end{itemize}

Revisa \java{ListClientExample} y asegúrate de entender lo que
hace. Luego, compílalo y ejecútalo. Si usas Ant, puedes navegar al
directorio {\tt code} y ejecutar {\tt ant ListClientExample}.

\index{Ant}

Puede ser que obtengas una advertencia como:

\begin{verbatim}
List is a raw type. References to generic type List<E> 
should be parameterized.
\end{verbatim}

Para mantener este ejemplo simple, no me preocupé por especificar el tipo de
los elementos en la lista.  Si esta advertencia te molesta, puedes
arreglarla reemplazando \java{List} o \java{LinkedList} con
\java{List<Integer>} o \java{LinkedList<Integer>}.

\index{raw type}

Revisa \java{ListClientExampleTest}. Ejecuta solo un prueba, que crea un
\java{ListClientExample}, invoca \java{getList}, y luego comprueba
si el resultado es una \java{ArrayList}. Inicialmente, este test fallará
porque el resultado es una \java{LinkedList}, no una
\java{ArrayList}. Ejecuta el test y confirma que falla.

NOTA: Este test tiene sentido para este ejercicio, pero no es un buen
ejemplo de un test. Los buenos tests deberían comprobar si la clase
que está siendo probada satisface los requerimientos de la \emph{interfaz}; 
no deberían depender de los detalles de la \emph{implementación}.

\index{}
\index{interfaz}
\index{implementación}

En la \java{ListClientExample}, reemplaza \java{LinkedList} con
\java{ArrayList}.  Podrías tener que agregar una instrucción \java{import}. 
Compila y ejecuta \java{ListClientExample}. Entonces ejecuta el test
de nuevo. Con este cambio, el test debería pasar.

Para lograr que se pase el test, tuviste que cambiar \java{LinkedList} en
el constructor; no tuviste que cambiar nada en el resto de lugares donde
\java{List} aparece. ¿Qué sucedería si lo haces?  Adelante, reemplaza una
o más apariciones de \java{List} con \java{ArrayList}. El programa
debería seguir funcionando correctamente, pero ahora está
``sobre especificado''. Si cambias de idea en el futuro y quieres intercambiar
la interfaz de nuevo, tendrías que cambiar más código.

En el constructor de \java{ListClientExample}, ¿qué sucede si reemplazas
\java{ArrayList} con \java{List}? ¿por qué no puedes instanciar una \java{List}?

\index{constructor}


\chapter{Análisis de Algoritmos}
\label{cs-analysis-of-algorithms-readme}

Como vimos en el capítulo anterior, Java provee dos
implementaciones de la interfaz \java{List}, \java{ArrayList} y
\java{LinkedList}. Para algunas aplicaciones, \java{LinkedList} es más rápida;
para otras, \java{ArrayList} es más rápida.

\index{análisis de algoritmos}
\index{perfilado}

Para decidir cuál es mejor para una aplicación particular, una aproximación
es probar ambas y ver cuánto se tardan. Esta aproximación, que se conoce
como ``perfilado'', tiene algunos problemas:

\begin{enumerate}

\item Antes de comparar los algoritmos, tienes que implementar ambos.

\item Los resultados podrían depender de qué tipo de computadora uses. Un 
  algoritmo podría ser mejor en una máquina; el otro podría ser mejor
  en una máquina diferente.

\item Los resultados podrían depender del tamaño del problema o de los datos
  que se proporcionaron como entrada.

\end{enumerate}

Podemos superar algunos de estos problemas al realizar un {\bf análisis de
algoritmos}. Cuando funciona, el análisis de algoritmos hace posible
comparar algoritmos sin tener que implementarlos. Pero tenemos que
asumir algunos supuestos:

\begin{enumerate}

\item Para no lidiar con los detalles del hardware de computadoras, 
  usualmente identificamos las operaciones básicas que conforman un
  algoritmo ---como suma, multiplicación y comparación de números--- y
  contamos el número de operaciones que cada algoritmo requiere.

\item Para no lidiar con los detalles de los datos de entrada, la mejor
  opción es analizar el desempeño promedio para las entradas que
  esperamos. Si eso no es posible, una alternativa común es analizar
  el peor escenario.

\item Finalmente, tenemos que lidiar con la posibilidad que un algoritmo
  funcione mejor para problemas pequeños y otro para los grandes. En ese
  caso, usualmente nos enfocamos en los grandes, porque para problemas
  pequeños la diferencia probablemente no importe, pero para problemas
  grandes la diferencia puede ser enorme.

\end{enumerate}

Esta clase de análisis conduce a una clasificación simple de los
algoritmos. Por ejemplo, si sabemos que el tiempo de ejecución del Algoritmo
A tiende a ser proporcional al tamaño de las entradas, $n$, y el Algoritmo
B tiende a ser proporcional a $n^2$, esperaríamos que A sea más rápido que B,
al menos para valores grandes de $n$.

\index{tiempo constante}
\index{tiempo lineal}
\index{tiempo cuadrático}

La mayoría de algoritmos simples pueden agruparse en unas pocas categorías.

\begin{itemize}

\item Tiempo constante: Un algoritmo es de ``tiempo constante'' si el tiempo de ejecución
  no depende del tamaño de las entradas. Por ejemplo, si tienes un
  arreglo de $n$ elementos y usas el operador de corchetes
  (\java{[]}) para acceder a uno de los elementos, esta operación requiere el mismo
  número de operaciones independientemente de qué tan grande sea el arreglo.

\item Lineal: Un algoritmo es ``lineal'' si el tiempo de ejecución es
  proporcional al tamaño de la entrada. Por ejemplo, si sumas todos los
  elementos de un arreglo, tienes que acceder a $n$ elementos y
  realizar $n-1$ sumas. El número total de operaciones
  (accesos a elementos y sumas) es $2n-1$, que es proporcional
  a $n$.

\item Cuadrático: Un algoritmo es ``cuadrático'' si el tiempo de ejecución es
  proporcional a $n^2$.  Por ejemplo, supón que quieres comprobar si cualquiera
  de los elementos en una lista aparece más de una vez. Un algoritmo simple
  es comparar cada elemento con todos los demás. Si hay
  $n$ elementos y cada se compara a los $n-1$ restantes, el número
  total de comparaciones es $n^2 -n$, que es proporcional a
  $n^2$ conforme $n$ crece.

\end{itemize}


\section{Ordenamiento por selección}
\label{selection-sort}

\index{ordenamiento por selección}
\index{ordenamiento}

Por ejemplo, aquí está una implementación de un algoritmo simple llamado
{\bf ordenamiento por selección}
(véase \url{http://thinkdast.com/selectsort}):

\begin{verbatim}
public class SelectionSort {

    /**
     * Intercambia los elementos en los índices i y j.
     */
    public static void swapElements(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    /**
     * Encuentra el índice del valor más bajo
     * comenzando desde el índice al principio (inclusive)
     * y continuando hasta el final del arreglo.
     */
    public static int indexLowest(int[] array, int start) {
        int lowIndex = start;
        for (int i = start; i < array.length; i++) {
            if (array[i] < array[lowIndex]) {
                lowIndex = i;
            }
        }
        return lowIndex;
    }

    /**
     * Ordena los elementos (en sitio) por selección.
     */
    public static void selectionSort(int[] array) {
        for (int i = 0; i < array.length; i++) {
            int j = indexLowest(array, i);
            swapElements(array, i, j);
        }
    }
}
\end{verbatim}

El primer método, \java{swapElements}, intercambia (del inglés \emph{swap}) dos elementos del
arreglo. Leer y escribir elementos son operaciones de tiempo constante,
porque si conocemos el número de elementos y la ubicación del primero,
podemos calcular la ubicación de cualquier otro elemento con una multiplicación
y una suma, y estas son operaciones de tiempo constante. Dado que todo en
\java{swapElements} es de tiempo constante, el método completo es de tiempo constante.

\index{tiempo constante}
El segundo método, \java{indexLowest}, encuentra el índice del elemento más
pequeño del arreglo comenzando en un índice dado, \java{start}. Cada vez,
en todas las repeticiones, accede a dos elementos del arreglo y
realiza una comparación. Dado que estas son todas operaciones de tiempo
constante, realmente no importa cuáles contemos. Para mantenerlo simple,
contemos el número de comparaciones.

\begin{enumerate}

\item Si \java{start} es 0, \java{indexLowest} recorre el arreglo
  completo, y el número total de comparaciones es la longitud del
  arreglo, a la que llamaré $n$.

\item Si \java{start} es 1, el número de comparaciones es $n-1$.

\item En general, el número de comparaciones es $n$ - \java{start}, así que 
  \java{indexLowest} es lineal.

\end{enumerate}

El tercer método, \java{selectionSort}, ordena el arreglo. Se repite desde
0 hasta $n-1$, así que el bucle se ejecuta $n$ veces. Cada vez, llama
a \java{indexLowest} y luego realiza una operación de tiempo constante,
\java{swapElements}.

\index{tiempo lineal}

La primera vez que se llama a \java{indexLowest}, éste lleva
a cabo $n$ comparaciones. La segunda vez, se llevan a cabo
$n-1$ comparaciones, y así sucesivamente. El número total de comparaciones es

\[ n + n-1 + n-2 + ... + 1 + 0 \]

La suma de esta serie es $n(n+1)/2$, que es proporcional a
$n^2$; eso implica que \java{selectionSort} es cuadrático.

\index{tiempo lineal}

Para obtener el mismo resultado de forma diferente, podemos pensar en
\java{indexLowest} como un bucle anidado. Cada vez que llamamos a
\java{indexLowest}, el número de operaciones es proporcional
a $n$. Lo llamamos $n$ veces, así que el número total de
operaciones es proporcional a $n^2$.


\section{Notación Big O}
\label{big-o-notation}

\index{notación Big O}

Todos los algoritmos de tiempo constante pertenecen a un conjunto
llamado $O(1)$. Así que otra manera de decir que un algoritmo es de
tiempo constante es decir que está en $O(1)$. De forma similar, todos
los algoritmos lineales pertenecen a $O(n)$, y todos los algoritmos
cuadráticos pertenecen a $O(n^2)$. A esta forma de clasificar algoritmos
se la conoce como ``notación big O''.

NOTA: Esta es un definición informal de la notación big O. Para un
tratamiento más formal, véase
\url{http://thinkdast.com/bigo}.

Esta notación provee una manera conveniente de escribir reglas generales
acerca de cómo se comportan los algoritmos cuando los combinamos. Por
ejemplo, si se lleva a cabo un algoritmo de tiempo lineal seguido de un
algoritmo constante, el tiempo total de ejecución es lineal. Al usar $\in$
con el significado ``pertenece a'':

Si $f \in O(n)$ u $g \in O(1)$, $f+g \in O(n)$.

Si se llevan a cabo dos operaciones lineales, el total sigue siendo lineal.

Si $f \in O(n)$ y $g \in O(n)$, $f+g \in O(n)$.

De hecho, si se lleva a cabo una operación lineal cualquier número
de veces, $k$, el total es lineal, siempre que $k$ sea una constante
que no dependa de $n$.

Si $f \in O(n)$ y $k$ es una constante, $kf \in O(n)$.

Pero si llevas a cabo una operación lineal $n$ veces, el resultado
es cuadrático:

Si $f \in O(n)$, $nf \in O(n^2)$.

En general, sólo nos interesa el exponente mayor de $n$. Así que si
el número total de operaciones es $2n + 1$, pertenece a
$O(n)$. El coeficiente, 2, y el término aditivo, 1, no son importantes
para este tipo de análisis. De forma similar, $n^2 + 100n + 1000$ está
en $O(n^2)$.  ¡Que no te distraigan los números grandes!

``Orden de crecimiento'' es otro nombre para la misma idea. Una orden de
crecimiento es un conjunto de algoritmos cuyos tiempos de ejecución están
en la misma categoría de big O; por ejemplo, todos los algoritmos lineales
pertenecen a la misma orden de crecimiento porque sus tiempos de ejecución
están en $O(n)$.

\index{orden de crecimiento}

En este contexto, una``orden'' es un grupo, como la \emph{Orden de
los Caballeros de la Mesa Redonda}, que es un grupo de caballeros, no una forma
de alinearlos. Así que puedes imaginarte a la \emph{Orden de los Algoritmos
Lineales} como un conjunto de algoritmos valientes, galantes y particularmente eficientes.


\section{Ejercicio 2}
\label{exercise2}

El ejercicio para este capítulo es implementar una \java{List} que
use un arreglo de Java para guardar sus elementos. 

En el repositorio de código para este libro (véase la Sección~\ref{code}),
encontrarás los archivos de código fuente que necesitarás:

\index{MyArrayList}

\begin{itemize}
\item \java{MyArrayList.java} contiene una implementación parcial de la interfaz de
 \java{List}. Cuatro de los métodos están incompletos, tu trabajo es agregar las partes faltantes.

\item \java{MyArrayListTest.java} contiene tests de JUnit que puedes usar para comprobar tu trabajo.

\end{itemize}

También encontrarás el archivo de construcción Ant \java{build.xml}.  Desde el
directorio {\tt code}, deberías poder ejecutar \java{ant MyArrayList} para
ejecutar \java{MyArrayList.java}, que contiene unos pocos tests simples. O puedes
ejecutar \java{ant MyArrayListTest} para ejecutar los tests de JUnit.

\index{Ant}
%TODO: either make the build step automatic or add instructions

Cuando ejecutes los tests, varios de ellos deberían fallar. Si examinas el
código fuente, verás cuatro comentarios \java{TODO} (cosas por hacer)
indicando los métodos que deberías completar.

Antes de comenzar a agregar el código en los métodos incompletos, revisemos
una porción del código. Aquí esta la definición de la clase, variables de instancia
y el constructor.

\index{variable de instancia}
\index{constructor}


\begin{verbatim}
public class MyArrayList<E> implements List<E> {
    int size;                    // lleva un registro del número de elementos
    private E[] array;           // guarda los elementos
    
    public MyArrayList() {
        array = (E[]) new Object[10];
        size = 0;
    }
}
\end{verbatim}

Como indican los comentarios, \java{size} registra cuántos elementos
están en \java{MyArrayList}, y \java{array} es el arreglo que, de hecho,
contiene los elementos.

\index{elemento}

El constructor crea un arreglo de 10 elementos, que inicialmente son
\java{null}, y establece el \java{size} en 0. La mayor parte del tiempo, la
longitud del arreglo es mayor que \java{size}, así que hay muchos espacios
sin utilizar en el arreglo.

\index{parámetro de tipo}

Un detalle sobre Java: no puedes instanciar  un arreglo usando un parámetro
de tipo; por ejemplo, lo siguiente no funcionará:

\begin{verbatim}
        array = new E[10];
\end{verbatim}

Para superar esta limitante, tendrás que instanciar un arreglo de
\java{Object} y después forzar la conversión de tipo. Puedes leer más al respecto
en \url{http://thinkdast.com/generics}.

A continuación examinaremos el método que agrega elementos a la lista:

\begin{verbatim}
    public boolean add(E element) {
        if (size >= array.length) {
            // crear un arreglo más grande y copiar los elementos
            E[] bigger = (E[]) new Object[array.length * 2];
            System.arraycopy(array, 0, bigger, 0, array.length);
            array = bigger;
        } 
        array[size] = element;
        size++;
        return true;
    }
\end{verbatim}

Si no hay espacios sin utilizar en el arreglo, tenemos que crear un arreglo
más grande y copiar los elementos a éste. Luego ya podemos guardar el
elemento en el arreglo e incrementar el \java{size}.

\index{booleano}

Puede que no sea obvio por qué este método devuelve un booleano, dado
que siempre devuelve \java{true}. Como siempre, puedes encontrar la
respuesta en la documentación:
\url{http://thinkdast.com/colladd}.
Tampoco es obvio cómo analizar el desempeño de este
método. En el caso normal, es de tiempo constante, pero si tenemos
que redimensionar el arreglo, es lineal. Explicaré cómo manejar esto en la
Sección~\ref{classifying-add}.

\index{tiempo constante}
\index{tiempo lineal}

Finalmente, demos una mirada a \java{get}; y luego ya puedes empezar con
los ejercicios.

\begin{verbatim}
    public T get(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException();
        }
        return array[index];
    }
\end{verbatim}

De hecho, \java{get} es bastante simple:
si el índice está fuera de rango, lanza una excepción; de lo contrario
lee y devuelve un elemento del arreglo. Nota que se comprueba si
el índice es menor que \java{size}, no \java{array.length}, así que
no es posible acceder a los elementos sin utilizar del arreglo.

\index{get}

En \java{MyArrayList.java}, encontrarás código de relleno para \java{set} que
se ve como esto:

\begin{verbatim}
    public T set(int index, T element) {
        // TODO: fill in this method.
        return null;
    }
\end{verbatim}

Lee la documentación de \java{set} en
\url{http://thinkdast.com/listset}, luego llena el cuerpo de este
método. Si ejecutas \java{MyArrayListTest} de nuevo, \java{testSet} debería
pasar.

\index{set}

PISTA: Trata de no repetir el código que comprueba el índice.

Tu siguiente misión es llenar \java{indexOf}. Como es usual, debería
leer la documentación en \url{http://thinkdast.com/listindof} así ya
sabes lo que se supone que haga. En particular, nota cómo se supone
que maneje \java{null}.

\index{indexOf}
\index{método auxiliar}

He provisto un método auxiliar llamado
\java{equals} que compara un elementos del arreglo con un valor
objetivo y devuelve \java{true} si son iguales (y que maneja los
\java{null} correctamente). Nota que este método es privado porque solo
se usa dentro de la clase; no es parte de la interfaz \java{List}.

\index{equals}

Cuando termines, ejecuta \java{MyArrayListTest} de nuevo;
\java{testIndexOf} debería pasar ahora, así como el otro test que
depende de él.

Sólo dos métodos más para terminar, y habrás finalizado este
ejercicio. El siguiente es una versión sobrecargada de \java{add} que
toma un entero y guarda el nuevo valor en un índice dado, desplazando
los otros elementos para hacer espacio, de ser necesario.

\index{add}

De nuevo, lee la documentación en \url{http://thinkdast.com/listadd},
escribe una implementación, y ejecuta los tests para confirmar.

PISTA: Evita repetir el código que hace al arreglo más grande.

El último: llena el cuerpo de \java{remove}.  La documentación está en
\url{http://thinkdast.com/listrem}. Cuando finalices este útlimo, todos
los tests deberían pasar.

\index{remove}

Una vez que tus implementaciones funcionen, compáralas con la mía,
la cual puedes leer en \url{http://thinkdast.com/myarraylist}.


\chapter{ArrayList}
\label{cs-analyzing-our-arraylist-readme}

\index{ArrayList}

Este capítulo mata dos pájaros de un tiro: presento las soluciones
al ejercicio anterior y demuestro una forma de clasificar
algoritmos utilizando el {\bf análisis amortizado}.

\index{análisis amortizado}


\section{Clasificación de métodos de MyArrayList}
\label{classifying-myarraylist-methods}

Para muchos métodos, podemos identificar la orden de crecimiento al
examinar el código. Por ejemplo, aquí está la implementación de \java{get} de
\java{MyArrayList}:

\begin{verbatim}
    public E get(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException();
        }
        return array[index];
    }
\end{verbatim}

Todo en \java{get} es de tiempo constante, así que \java{get} es de tiempo
constante. Sin problemas.

\index{tiempo constante}
\index{get}

Ahora que hemos clasificado \java{get}, podemos clasificar \java{set},
que lo usa. Aquí está nuestra implementación de \java{set} del
ejercicio anterior:

\begin{verbatim}
    public E set(int index, E element) {
        E old = get(index);
        array[index] = element;
        return old;
    }
\end{verbatim}

Una parte ligeramente astuta de esta solución es que no comprueba los
límites del arreglo de forma explícita, sino que se aprovecha de \java{get},
que lanza una excepción si el índice es inválido.

\index{excepción}
\index{set}

Todo en \java{set}, incluso la invocación de \java{get}, es de
tiempo constante, así que \java{set} también es de tiempo constante.

\index{indexOf}
\index{tiempo lineal}

Luego examinaremos algunos métodos lineales. Por ejemplo, aquí esta mi
implementación de \java{indexOf}:

\begin{verbatim}
    public int indexOf(Object target) {
        for (int i = 0; i<size; i++) {
            if (equals(target, array[i])) {
                return i;
            }
        }
        return -1;
    }
\end{verbatim}

En cada repetición del bucle, \java{indexOf} invoca a \java{equals}, así que
tenemos que clasificar a \java{equals} primero. Aquí está:

\begin{verbatim}
    private boolean equals(Object target, Object element) {
        if (target == null) {
            return element == null;
        } else {
            return target.equals(element);
        }
    }
\end{verbatim}

Este método invoca a \java{target.equals}; el tiempo de ejecución de este
método podría depender del tamaño de \java{target} o de \java{element}, pero
probablemente no depende del tamaño del arreglo, así que lo consideraremos
de tiempo constante para el propósito de de analizar \java{indexOf}.

\index{tiempo constante}
\index{tiempo lineal}
\index{equals}

Regresando a \java{indexOf}, todo dentro del bucle es de tiempo constante, 
así que la siguiente pregunta que tenemos que considerar es: ¿cuántas veces
se repite el bucle?

Si tenemos suerte, podríamos encontrar que el valor objetivo (target) al
principio y devolverlo después de comprobar sólo un elemento. Si somos
desafortunados, podríamos tener que comprobar todos los elementos. En
promedio, esperaríamos comprobar la mitad de los elementos, así que este
método es considerado lineal (excepto en el improbable caso que
sepamos que el elemento objetivo está al principio del arreglo).

\index{remove}

El análisis de \java{remove} es similar. Aquí está mi implementación:

\begin{verbatim}
    public E remove(int index) {
        E element = get(index);
        for (int i=index; i<size-1; i++) {
            array[i] = array[i+1];
        }
        size--;
        return element;
    }
\end{verbatim}

Este método usa a \java{get}, que es de tiempo constante, y luego itera a lo
largo del arreglo, comenzando en \java{index}. Si removemos el elemento al final
de la lista, el bucle nunca se ejecuta y este método es de tiempo constante. Si
removemos el primer elemento, recorreremos todos los elementos restantes, lo
que es lineal. Así que, de nuevo, este método se considera lineal (excepto en el
caso especial donde sabemos que elemento está al final o a una distancia constante
del final).


\section{Clasificación de \java{add}}
\label{classifying-add}

Aquí está una versión de \java{add} que toma un índice y un elemento como parámetros:

\begin{verbatim}
    public void add(int index, E element) {
        if (index < 0 || index > size) {
            throw new IndexOutOfBoundsException();
        }
        // agregar el elemento para forzar el redimensionamiento
        add(element);
        
        // desplaza los otros elementos
        for (int i=size-1; i>index; i--) {
            array[i] = array[i-1];
        }
        // coloca el nuevo elemento en el lugar correcto
        array[index] = element;
    }
\end{verbatim}

Esta versión con dos parámetros, llamada \java{add(int, E)}, usa a
la versión con un parámetros, llamada \java{add(E)}, que agrega un
nuevo elemento al final. Luego desplaza los otros elementos a la derecha,
y coloca el nuevo elemento en el lugar correcto.

\index{add}

Antes de clasificar \java{add(int, E)} con dos parámetros, tenemos que
clasificar \java{add(E)} con un parámetro:

\begin{verbatim}
    public boolean add(E element) {
        if (size >= array.length) {
            // make a bigger array and copy over the elements
            E[] bigger = (E[]) new Object[array.length * 2];
            System.arraycopy(array, 0, bigger, 0, array.length);
            array = bigger;
        } 
        array[size] = element;
        size++;
        return true;
    }
\end{verbatim}

La versión con un parámetro resulta difícil de analizar. Si hay un espacio
sin utilizar en el arreglo, es de tiempo constante, pero si tenemos que
redimensionar el arreglo, es lineal porque \java{System.arraycopy} toma
tiempo proporcional al tamaño del arreglo. 

\index{tiempo constante}
\index{tiempo lineal}

¿Así que es {\tt add} de tiempo constante o lineal?
Podemos clasificar este método al pensar en el número promedio de
operaciones por add en una serie de $n$ adds. Por simplicidad,
asume que comenzamos con un arreglo que tiene espacio para 2 elementos.

\begin{itemize}

\item
  La primera vez que llamamos a add, encuentra un espacio libre en el arreglo, así que
  guarda un elemento.

\item
  La segunda vez, encuentra un espacio libre en el arreglo, así que guarda 1
  elemento.

\item
  La tercera vez, tenemos que redimensionar el arreglo, copiar 2 elementos y
  guardar un elemento. Ahora el tamaño del arreglo es 4.

\item
  La cuarta vez se guarda un elemento.

\item
  La quinta vez redimensiona el arreglo, copia 4 elementos, y guarda 1
  elemento. Ahora el tamaño del arreglo es 8.

\item
  Los siguientes 3 llamados a add guardan 3 elementos.

\item
  El siguiente add copia 8 y guarda 1. Ahora el tamaño es 16.

\item
  Los siguientes 7 llamados a add guardan 7 elementos.

\end{itemize}

Y así sucesivamente. Juntando todo:

\begin{itemize}

\item
  Tras 4 llamados a add, hemos guardado 4 elementos y copiado 2.

\item
  Tras 8 llamados a add, hemos guardado 8 elementos y copiado 6.

\item
  Tras 16 llamados a add, hemos guardado 16 elementos y copiado 14.

\end{itemize}

Por ahora ya deberías ver el patrón: para llamar a add $n$ veces, tenemos
que guardar $n$ elementos y copiar $n-2$. Así que el número total de
operaciones es $n + n - 2$, que es $2n-2$.

Para obtener el número promedio de operaciones por add, dividimos el total por
$n$; el resultado es $2 - 2/n$. Conforme $n$ se hace más grande, el
segundo término, $2/n$, se hace más pequeño. Si tenemos en cuenta el principio que
sólo nos interesa el exponente mayor de $n$, podemos pensar en
\java{add} como de tiempo constante.

\index{tiempo constante}
\index{tiempo lineal}

Podría parecer extraño que un algoritmo que a veces es lineal puede ser de
tiempo constante en promedio. La clave es que duplicamos la longitud del
arreglo cada vez que se redimensiona. Esto limita el número de veces que
cada elemento es copiado. De otra manera --- si agregáramos una cantidad
fija a la longitud del arreglo, en lugar de multiplicar por una cantidad fija --- el
análisis no funcionaría.

% NOTE: Patrick notes potential confusion in my use of average, which
% was an average over a hypothetical set of inputs when we looked at
% indexOf, and here is the average over a sequence of operations.

% I am inclined to leave this alone on the grounds that it it more
% confusing for experts (who know the difference between average
% case analysis and amortized analysis) than for beginners (who will
% not, I conjecture, be bothered).

\index{análisis amortizado}
\index{tiempo promedio}

Esta forma de clasificar un algoritmo, al calcular el tiempo promedio en una
serie de invocaciones, es llamada {\bf análisis amortizado}.  Puedes
leer más al respecto en
\url{http://thinkdast.com/amort}. 
La idea clave es que el costo extra de copiar el arreglo es distribuido,
o ``amortizado'', entre una serie de invocaciones.

Ahora, si \java{add(E)} es de tiempo constante, ¿qué sucede con
\java{add(int, E)}? Tras llamar a \java{add(E)}, itera a través de
parte del arreglo y desplaza elementos. Este bucle es lineal, excepto
en el caso especial donde estamos agregando al final de la lista. Así
que \java{add(int, E)} es lineal.

\index{tiempo lineal}


\section{Tamaño del problema}
\label{classifying-removeall}

El último ejemplo que consideraremos es \java{removeAll}; aquí está la
la implementación en \java{MyArrayList}:

\begin{verbatim}
    public boolean removeAll(Collection<?> collection) {
        boolean flag = true;
        for (Object obj: collection) {
            flag &= remove(obj);
        }
        return flag;
    }
\end{verbatim}

En cada repetición, \java{removeAll} invoca a \java{remove},
que es lineal.  Así que es tentador pensar que \java{removeAll} es
cuadrático.  Pero ese no es necesariamente el caso.

\index{tiempo cuadrático}

En este método, el bucle se ejecuta una vez para cada elemento en
\java{collection}. Si \java{collection} contiene $m$ elementos y la
lista de la que estamos removiendo contiene $n$ elementos, este método está en
$O(nm)$. Si el tamaño de la \java{collection} puede ser considerado constante,
\java{removeAll} es lineal con respecto a $n$. Pero si el tamaño de la
colección es proporcional a $n$, \java{removeAll} es cuadrático. Por ejemplo,
si \java{collection} siempre contiene 100 elementos o menos,
\java{removeAll} es lineal. Pero si \java{collection} generalmente
contiene 1\% de los elementos en la lista, \java{removeAll} es
cuadrático.

\index{tiempo constante}
\index{tamaño del problema}
\index{removeAll}

Cuando hablamos del {\bf tamaño del problema}, tenemos que ser cuidadosos con
respecto a cuál tamaño, o tamaños, estamos hablando. Este ejemplo demuestra
un error de bulto en el análisis de algoritmos: el tentador atajo de contar
bucles. Si sólo hay un bucle, el algoritmo es \emph{generalmente}
linear.  Si hay dos bucles (uno anidado dentro del otro), el algoritmo es
\emph{generalmente} cuadrático. ¡Pero ten cuidado! Tienes que pensar
en cuántas veces se ejecuta cada bucle. Si el número de iteraciones
proporcional a $n$ para todos los bucles, puedes salirte con la tuya limitándote
a contar los bucles. Pero si, como en este ejemplo, el número de iteraciones no es
siempre proporcional a $n$, tendrás que pensarlo con más detalle.


\section{Estructuras de datos enlazadas}
\label{linked-data-structures}

Para el siguiente ejercicio proveo una implementación parcial de la
interfaz \java{List} que usa una lista enlazada para guardar los elementos.
Si no estás familiarizado con las listas enlazadas, puedes leer sobre ellas en
\url{http://thinkdast.com/linkedlist},
pero esta sección provee una breve introducción.

\index{estructuras de datos enlazadas}
\index{nodo}

Una estructura de datos está ``enlazada'' si está formada por objetos, muchas veces llamados
``nodos'', que contienen referencias a los otros nodos. En una \emph{lista} enlazada,
cada nodo contiene una referencia al siguiente nodo en la lista. Otras estructuras enlazadas
incluyen árboles y grafos, en los cuales los nodos pueden contener referencias a más de
un nodo separado.

Aquí está una definición de clase para un nodo simple:

\begin{verbatim}
public class ListNode {

    public Object data;
    public ListNode next;

    public ListNode() {
        this.data = null;
        this.next = null;
    }

    public ListNode(Object data) {
        this.data = data;
        this.next = null;
    }

    public ListNode(Object data, ListNode next) {
        this.data = data;
        this.next = next;
    }

    public String toString() {
        return "ListNode(" + data.toString() + ")";
    }
}
\end{verbatim}

El objeto \java{ListNode} tiene dos variables de instancia: \java{data} es una
referencia a algún tipo de \java{Object}, y \java{next} es una referencia al
siguiente nodo en la lista. En el último nodo de la lista, por convención,
\java{next} es \java{null}.

\index{null}

\java{ListNode} provee varios constructores, permitiéndote proveer valores
para \java{data} y \java{next}, o inicializarlos con el valor por defecto, \java{null}.

\index{ListNode}

Puedes pensar en cada \java{ListNode} como una lista con un único elemento,
pero de forma más general, una lista puede contener cualquier número de nodos. Hay
varias manera de crear una nueva lista. Una opción simple es crear un conjunto de
objetos \java{ListNode}, así:

\begin{verbatim}
        ListNode node1 = new ListNode(1);
        ListNode node2 = new ListNode(2);
        ListNode node3 = new ListNode(3);
\end{verbatim}

Y luego enlazarlos, de esta manera:

\begin{verbatim}
        node1.next = node2;
        node2.next = node3;
        node3.next = null;
\end{verbatim}

Alternativamente, puedes crear un nodo y enlazarlo al mismo tiempo. Por
ejemplo, si quieres agregar un nuevo nodo al principio de una lista, puedes
hacerlo así::

\begin{verbatim}
        ListNode node0 = new ListNode(0, node1);
\end{verbatim}

Tras esta secuencia de instrucciones, tenemos cuatro nodos que contienen los
\java{Integer}s 0, 1, 2, y 3 como datos, enlazados en orden ascendente. En el
último nodo, el campo \java{next} es \java{null}.

\begin{figure}
\centering
\includegraphics[width=4in]{figs/linked_list1.pdf}
\caption{Diagrama de objeto de una lista enlazada.}
\label{linkedlistfig}
\end{figure}

\index{lista enlazada}
\index{diagrama de objeto}

La figura~\ref{linkedlistfig} es un diagrama de objeto que muestra estas
variables y los objetos a los que se refieren.  En un diagrama de objeto,
las variables aparecen como nombres fuera de las cajas, con flechas que muestran
a qué se refieren. Los objetos aparecen como cajas con su tipo en el exterior
(como \java{ListNode} y \java{Integer}) y sus variables de instancia en el interior.


\section{Ejercicio 3}
\label{exercise3}

En el repositorio para este libro, encontrarás los archivos
de código fuente que necesitas para este ejercicio:

\index{MyLinkedList}

\begin{itemize}

\item \java{MyLinkedList.java} contiene una implementación parcial de
  la interfaz \java{List} que usa una lista enlazada para guardar los elementos.

\item \java{MyLinkedListTest.java} contiene tests de JUnit para
  \java{MyLinkedList}.

\end{itemize}

Ejecute \java{ant MyLinkedList} para correr \java{MyLinkedList.java}, que
contiene unos pocos tests simples. 

Luego puedes ejecutar \java{ant MyLinkedListTest} para correr los tests de JUnit.
Varios de ellos deberían fallar. Si examinas el código fuente, encontrarás
tres comentarios \java{TODO} indicando los métodos que deberías rellenar.

Antes de iniciar, revisemos una porción del
código. Aquí están las variables de instancia y el constructor para
\java{MyLinkedList}:

\begin{verbatim}
public class MyLinkedList<E> implements List<E> {

    private int size;            // registra el número de elementos
    private Node head;           // referencia al primer nodo

    public MyLinkedList() {
        head = null;
        size = 0;
    }
}
\end{verbatim}

Como lo indican los comentarios, \java{size} lleva el control de cuántos elementos
están en \java{MyLinkedList}; \java{head} es una referencia al primer
\java{Node} en la lista o \java{null} si la lista está vacía.

\index{MyLinkedList}

Guardar el número de elementos no es necesario y en general es
riesgoso mantener información redundante, porque si no se actualiza
correctamente, crea oportunidades para cometer errores. Además
toma un poquito de espacio extra.

\index{size}

Pero si guardamos \java{size} explícitamente, podemos implementar el
método \java{size} en tiempo constante; de otra forma, tendríamos que
recorrer toda la lista y contar los elementos, lo que requiere tiempo lineal.

\index{tiempo constante}
\index{tiempo lineal}

Porque guardamos \java{size} explícitamente, tenemos que actualizarlo cada
vez que agregamos o removemos un elemento, así que hace un poco más lentos
estos métodos, pero no cambia su orden de crecimiento, por lo que probablemente
vale la pena.

El constructor establece \java{head} en \java{null}, lo que indica una lista
vacía, y establece \java{size} en 0.

\index{parámetro de tipo}

Esta clase usa un parámetro de tipo \java{E} para el tipo de
elementos. Si no estás familiarizado con los parámetros de tipo, podrías
querer leer este tutorial:
\url{http://thinkdast.com/types}.

El parámetro de tipo también aparece en la definición de \java{Node},
que está anidada dentro de \java{MyLinkedList}:

\begin{verbatim}
    private class Node {
        public E data;
        public Node next;

        public Node(E data, Node next) {
            this.data = data;
            this.next = next;
        }
    }
\end{verbatim}

Aparte de eso, \java{Node} es similar a \java{ListNode}, presentada anteriormente.

\index{Node}
\index{add}

Finalmente, aquí está mi implementación de \java{add}:

\begin{verbatim}
    public boolean add(E element) {
        if (head == null) {
            head = new Node(element);
        } else {
            Node node = head;
            // loop until the last node
            for ( ; node.next != null; node = node.next) {}
            node.next = new Node(element);
        }
        size++;
        return true;
    }
\end{verbatim}

\index{caso especial}

Este ejemplo demuestra dos patrones que necesitarás para tus soluciones:

\begin{enumerate}

\item
  Para muchos métodos, tenemos que tratar al primer elemento de la lista como un
  caso especial. En este ejemplo, si estamos agregando el primer elemento de una
  lista, tenemos que modificar \java{head}. De lo contrario, recorremos la
  lista, encontramos el final, y agregamos el nuevo nodo.

\item
  Este método muestra cómo usar un bucle \java{for} para recorrer los nodos
  en una lista. En tus soluciones, probablemente escribirás varias
  variantes de este bucle. Nota que tenemos que declarar \java{node}
  antes del bucle para poder acceder a él después del bucle.

\end{enumerate}

Ahora es tu turno. Llena el cuerpo de \java{indexOf}.  Como es lo usual,
deberías leer la documentación, en
\url{http://thinkdast.com/listindof},
para que sepas lo que se supone que debe hacer. En particular, nota cómo se
supone que maneje los \java{null}.

\index{método auxiliar}

Como en el ejercicio anterior, proveo un método auxiliar llamado
\java{equals} que compara un elemento de un arreglo a un valor objetivo
y comprueba si son iguales --- y que maneja los \java{null}
correctamente. Este método es privado porque se usa dentro de esta clase
pero no es parte de la interfaz \java{List}.

Cuando termines, ejecuta los tests de nuevo; \java{testIndexOf}
debería pasar ahora, así como los otros tests que dependen de él.

\index{add}

Luego, deberías completar la versión con dos parámetros de \java{add},
que toma un índice y guarda el nuevo valor en el índice dado.
De nuevo, lee la documentación en \url{http://thinkdast.com/listadd},
escriba una implementación y ejecuta los tests para confirmar.

\index{remove}

El último: llena el cuerpo de \java{remove}.  Aquí está la documentación:
\url{http://thinkdast.com/listrem}.  Cuando finalices este, todos los tests
deberían pasar.

Una vez que tus implementaciones funcionen, compáralas a la versión
en el directorio \java{solution} del repositorio.


\section{Una nota sobre la recolección de basura}
\label{a-note-on-garbage-collection}

En \java{MyArrayList} del ejercicio anterior, el arreglo crece si es
necesario, pero nunca se reduce. El arreglo nunca es recolectado y los
elementos no son limpiados por el recolector de basura hasta que la lista
como tal es destruida.

\index{recolección de basura}

Una ventaja de la implementación de lista enlazada es que se reduce cuando
los elementos son removidos y los nodos sin utilizar son limpiados por el
recolector de basura inmediatamente.

\index{clear}

Aquí está mi implementación del método \java{clear}:

\begin{verbatim}
    public void clear() {
        head = null;
        size = 0;
    }
\end{verbatim}

Cuando establecemos el valor de \java{head} en \java{null}, removemos una
referencia al primer \java{Node}. Si no hay otras referencias a ese \java{Node}
(y no deberían haber), también es limpiado por el recolector de basura. Este
proceso continúa hasta que todos los nodos son limpiados.

Así que, ¿cómo deberíamos clasificar \java{clear}? El método en si mismo contiene dos
operaciones de tiempo constante, así que seguro parece como de tiempo constante. Pero
cuando lo invocas, haces que el recolector de basura realice un trabajo que es
proporcional al número de elementos. ¡Así que tal vez deberíamos considerarlo lineal!

\index{tiempo constante}
\index{tiempo lineal}
\index{bug de rendimiento}

Este es un ejemplo de lo que a veces se conoce como un {\bf bug de rendimiento}:
un programa que es correcto en el sentido que hace lo correcto,
pero que no pertenece a la orden de crecimiento que esperábamos. En lenguajes
como Java que realizan gran parte del trabajo, como la recolección de basura,
tras bambalinas, esta clase de bug puede ser difícil de encontrar.


\chapter{LinkedList}

Este capítulo presenta soluciones al ejercicio previo y continúa la
discusión sobre el análisis de algoritmos.


\section{Clasificación de los métodos de \java{MyLinkedList}}
\label{classifying-mylinkedlist-methods}

Mi implementación de \java{indexOf} se encuentra a continuación. Léela y mira
si puedes identificar su orden de crecimiento antes de leer la explicación.

\begin{verbatim}
    public int indexOf(Object target) {
        Node node = head;
        for (int i=0; i<size; i++) {
            if (equals(target, node.data)) {
                return i;
            }
            node = node.next;
        }
        return -1;
    }
\end{verbatim}

Inicialmente \java{node} obtiene una copia de \java{head}, así que ambos se
refieren al mismo \java{Node}. La variable de repetición, \java{i}, cuenta desde 0 hasta
\java{size-1}.  En cada repetición del bucle, usamos \java{equals} para
ver si hemos encontrado el objetivo (\java{target}). De ser así, devolvemos \java{i} inmediatamente.
De lo contrario, avanzamos al siguiente \java{Node} en la lista.

Normalmente deberíamos asegurarnos que el siguiente \java{Node} no sea
\java{null}, pero en este caso es seguro porque el bucle termina al llegar al
final de la lista (asumiendo que \java{size} es consistente con el número exacto de nodos en la lista).

Si el bucle finaliza sin haber encontrado al objetivo, devolvemos
\java{-1}.

\index{indexOf}
\index{tiempo constante}

Así que, ¿cuál es la orden de crecimiento para este método?

\begin{enumerate}

\item
  En cada repetición del bucle invocamos \java{equals}, que es de
  tiempo constante (lo que podría depender del tamaño de \java{target} o
  \java{data}, pero no depende del tamaño de la lista). Las
  otras operaciones en el bucle son también de tiempo constante.

\item
  El bucle podría ejecutarse $n$ veces, porque en el peor escenario,
  podríamos tener que recorrer la lista completa.

\end{enumerate}

Así que el tiempo de ejecución de este método es proporcional a la longitud
de la lista.

\index{add}

Para continuar, aquí está mi implementación del método \java{add}
con dos parámetros. De nuevo, deberías tratar de clasificarlo antes de
leer la explicación.

\begin{verbatim}
    public void add(int index, E element) {
        if (index == 0) {
            head = new Node(element, head);
        } else {
            Node node = getNode(index-1);
            node.next = new Node(element, node.next);
        }
        size++;
    }
\end{verbatim}

Si \java{index==0}, agregamos el nuevo \java{Node} al principio,
así que lo trataremos como un caso especial. De lo contrario, tendríamos
que recorrer la lista para encontrar el elemento en \java{index-1}. Usamos el
método auxiliar \java{getNode}:

\index{método auxiliar}

\begin{verbatim}
    private Node getNode(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException();
        }
        Node node = head;
        for (int i=0; i<index; i++) {
            node = node.next;
        }
        return node;
    }
\end{verbatim}

\java{getNode} comprueba si el \java{index} está fuera de rango; de ser así,
lanza una excepción. De otra forma, recorre la lista y devuelve el Nodo solicitado.

\index{getNode}

Volviendo a \java{add}, una vez encontramos el \java{Node} apropiado, creamos el
nuevo \java{Node} y lo colocamos entre \java{node} y \java{node.next}. Podrías
encontrar útil dibujar un diagrama de esta operación para estar seguro que la
entiendes.

Así, ¿cuál es la orden de crecimiento para \java{add}?

\begin{enumerate}

\item
  \java{getNode} es similar a
  \java{indexOf}, y es lineal por la misma razón.

\item
  En \java{add}, todo antes y después de \java{getNode} es
  de tiempo constante.

\end{enumerate}

Al combinar todo, \java{add} es lineal.

\index{tiempo constante}
\index{tiempo lineal}
\index{remove}

Finalmente, examinemos \java{remove}:

\begin{verbatim}
    public E remove(int index) {
        E element = get(index);
        if (index == 0) {
            head = head.next;
        } else {
            Node node = getNode(index-1);
            node.next = node.next.next;
        }
        size--;
        return element;
    }
\end{verbatim}

\java{remove} usa \java{get} para encontrar y guardar el elemento en
\java{index}. Luego remueve el \java{Node} que lo contiene.

Si \java{index==0}, de nuevo lo tratamos como un caso especial. De lo contrario
encontramos el nodo en \java{index-1} y lo modificamos para que se salte
\java{node.next} y se enlace directamente con \java{node.next.next}. Esto
efectivamente remueve \java{node.next} de la lista, y puede ser limpiado
por el recolector de basura.

Finalmente, disminuimos \java{size} y devolvemos el elemento que recuperamos
al principio.

Así, ¿cuál es la orden de crecimiento para \java{remove}? Todo en
\java{remove} es de tiempo constante excepto \java{get} y
\java{getNode}, que son lineales. Así que \java{remove} es lineal.

Cuando las personas ven dos operaciones lineales, a veces creen que el resultado
es cuadrático, pero eso solo aplica si una operación está anidada dentro de
la otra. Si invocas una operación después de la otra, los tiempos de ejecución
se suman. Si ambas están en $O(n)$, la suma también está en
$O(n)$.

\index{tiempo lineal}
\index{tiempo cuadrático}


\section{Comparación entre \java{MyArrayList} y \java{MyLinkedList}}
\label{comparing-mylinkedlist-and-myarraylist}

\index{MyArrayList}
\index{MyLinkedList}

La siguiente tabla resume las diferencias entre
\java{MyLinkedList} y \java{MyArrayList}, donde \java{1} significa
$O(1)$ o tiempo constante y $n$ significa $O(n)$ o
lineal.

\begin{tabular}[c]{@{}lll@{}}
\hline
& MyArrayList & MyLinkedList \\
\hline
add (al final) & \textbf{1} & n
\\
add (al principio) & n & \textbf{1}
\\
add (en general) & n & n
\\
get / set & \textbf{1} & n
\\
indexOf / lastIndexOf & n & n
\\
isEmpty / size & 1 & 1
\\
remove (del final) & \textbf{1} & n
\\
remove (del principio) & n & \textbf{1}
\\
remove (en general) & n & n
\\
\hline
\end{tabular}

Las operaciones en las \java{MyArrayList} destaca son agregar (add) al final,
remover (remove) del final, obtener (get) y establecer (set).

Las operaciones en las que \java{MyLinkedList} destaca son agregar al
principio y remover del principio.

Para otras operaciones, las dos implementaciones están en la misma orden
de crecimiento.

\index{orden de crecimiento}

¿Cuál implementación es mejor? Depende de cuáles operaciones es
probable que uses más. Y es por eso que Java provee más de una
implementación, porque esto depende.


\section{Perfilado}

Para el siguiente ejercicio proveo una clase llamada \java{Profiler} que
contiene código que ejecuta un método para varios tamaños de problemas,
mide el tiempo de ejecución y grafica los resultados.

\index{perfilado}

Usarás un \java{Profiler} (Perfilador) para clasificar el desempeño
de los métodos \java{add} para las implementaciones en Java de
\java{ArrayList} y \java{LinkedList}.

Aquí está un ejemplo que muestra como usar el perfilador:

\begin{verbatim}
    public static void profileArrayListAddEnd() {
        Timeable timeable = new Timeable() {
            List<String> list;

            public void setup(int n) {
                list = new ArrayList<String>();
            }

            public void timeMe(int n) {
                for (int i=0; i<n; i++) {
                    list.add("a string");
                }
            }
        };

        String title = "ArrayList add end";
        Profiler profiler = new Profiler(title, timeable);

        int startN = 4000;
        int endMillis = 1000;
        XYSeries series = profiler.timingLoop(startN, endMillis);
        profiler.plotResults(series);
    }
\end{verbatim}

Este método mide el tiempo que toma ejecutar \java{add} en una
\java{ArrayList}, el cual agrega el nuevo elemento al final. Explicaré
el código y luego mostraré los resultados.

\index{add}

Para usar el \java{Profiler}, necesitamos crear un objeto \java{Timeable}
que provee dos métodos: \java{setup} y \java{timeMe}.
El método \java{setup} hace lo que sea que se necesite hacer antes de iniciar
el cronómetro; en este caso crea una lista vacía. Luego \java{timeMe}
realiza cualquier operación que estemos tratando de medir; en este caso
agrega $n$ elementos a la lista.

\index{Profiler}
\index{Timeable}
\index{clase anónima}

El código que crea \java{timeable} es una {\bf clase anónima} que
define una nueva implementación de la interfaz \java{Timeable} y
crea una instancia de la nueva clase al mismo tiempo. Si no estás
familiarizado con las clases anónimas, puedes leer sobre ellas aquí:
\url{http://thinkdast.com/anonclass}.

Pero no necesitas conocer mucho para el siguiente ejercicio; incluso si
no te sientes cómodo con las clases anónimas, puedes copiar
y modificar el código de ejemplo.

El siguiente paso es crear el objeto \java{Profiler} pasándole el
objeto \java{Timeable} y un título como parámetros.

El \java{Profiler} provee \java{timingLoop} que usa el objeto
\java{Timeable} guardado como una variable de instancia. Éste invoca al
método \java{timeMe} en el objeto \java{Timeable} varias veces
con un rango de valores de $n$. \java{timingLoop} toma dos
parámetros:

\begin{itemize}

\item
  \java{startN} es el valor de $n$ con el que debería iniciar el
  temporizador.

\item
  \java{endMillis} es un umbral en milisegundos. Conforme
  \java{timingLoop} incrementa el tamaño del problema, el tiempo de ejecución se incrementa;
  cuando el tiempo de ejecución sobrepasa este umbral, \java{timingLoop} se detiene.

\end{itemize}

Cuando realices los experimentos, podrías tener que ajustar estos
parámetros. Si \java{startN} es muy bajo, el tiempo de ejecución podría
ser muy corto para medirlo con exactitud. Si \java{endMillis} es muy bajo, puede
que no obtengas datos suficientes para ver una relación clara entre el tamaño del
problema y el tiempo de ejecución.

Este código está en \java{ProfileListAdd.java}, que ejecutarás en el siguiente
ejercicio. Cuando yo lo ejecuté, obtuve esta salida:

\begin{verbatim}
4000, 3
8000, 0
16000, 1
32000, 2
64000, 3
128000, 6
256000, 18
512000, 30
1024000, 88
2048000, 185
4096000, 242
8192000, 544
16384000, 1325
\end{verbatim}

La primera columna es el tamaño del problema, $n$; la segunda columna es
el tiempo de ejecución en milisegundos. Las primeras mediciones contienen
bastante ruido, podría haber sido mejor establecer \java{startN} alrededor de 64000.

\index{XYSeries}

El resultado del \java{timingLoop} es una \java{XYSeries} que
contiene estos datos. Si pasas esta serie a \java{plotResults},
genera una gráfica como la de Figura~\ref{fig-profile1}.

\begin{figure}
\centering
\includegraphics[height=2.5in]{figs/profile1.png}
\caption{Resultados del perfilado: tiempo de ejecución versus tamaño del problema para
agregar $n$ elementos al final de una \java{ArrayList}.}
\label{fig-profile1}
\end{figure}

La siguiente sección explica cómo interpretarla.


\section{Interpretación de los resultados}\label{interpreting-results}

Con base en nuestro entendimiento sobre cómo funciona \java{ArrayList},
esperaríamos que el método \java{add} tome una cantidad de tiempo constante
cuando agregamos elementos al final. Así que el tiempo total para agregar $n$
elementos debería ser lineal.

\index{tiempo constante}
\index{tiempo lineal}
\index{ArrayList}

Para comprobar esta teoría, podríamos graficar el tiempo total de ejecución
versus el tamaño del problema, y deberíamos ver una línea recta, al menos
para tamaños de problemas lo suficientemente grandes para obtener mediciones
precisas. Matemáticamente, podemos escribir la función para esa línea:

\newcommand{\runtime}{\mbox{tiempo de ejecución}}

\[ \runtime = a + b n \]

donde $a$ es la intersección de la línea y $b$ es la pendiente.

\index{tiempo cuadrático}

Por otro lado, si \java{add} es lineal, el tiempo total para
$n$ adds sería cuadrático. Si graficamos el tiempo de ejecución versus el tamaño
del problema, esperaríamos ver una parábola. O matemáticamente, algo como:

\[ \runtime = a + b n + c n^2 \]

Con datos perfectos, podríamos ser capaces de distinguir entre una línea
recta y una parábola, pero si las mediciones contienen ruido, esto puede
ser difícil. Una mejor manera de interpretar mediciones con ruido es
graficar el tiempo de ejecución y el tamaño del problema en una
escala \textbf{log-log}.

\index{logaritmo}
\index{escala log-log}

¿Por qué? Supongamos que el tiempo de ejecución es proporcional
a $n^k$, pero no sabemos cuál es el exponente $k$. Podemos escribir la
relación como sigue:

\[ \runtime = a + b n + \ldots + c n^k \]

Para valores grandes de $n$, el término con el exponente mayor es el
más importante, así que:

\[ \runtime \approx c n^k \]

donde $\approx$ significa ``aproximadamente igual a''. Ahora, si
calculamos el logaritmo de ambos lados de la ecuación:

\[ \log(\runtime) \approx \log(c) + k \log(n) \]

Esta ecuación implica que si graficamos $\runtime$ versus $n$ en una
escala log-log, esperaríamos ver una línea recta con intersección
$\log(c)$ y pendiente $k$. No nos interesa mucho la intersección,
pero la pendiente indica la orden de crecimiento: si
$k=1$, el algoritmo es lineal; si $k=2$, es cuadrático.

\index{pendiente}

Al observar la figura de la sección previa, puedes estimar la
pendiente visualmente. Pero cuando llamas a \java{plotResults}
se calcula un ajuste de mínimos cuadrados y se imprime la pendiente
estimada. En este ejemplo:

\begin{verbatim}
Estimated slope = 1.06194352346708
\end{verbatim}

Que es cercano a 1; y eso sugiere que el tiempo total para $n$ llamadas a add
es lineal, así que cada add es de tiempo constante, tal como esperábamos.

\index{tiempo constante}

Un punto importante: si ves una línea recta en una gráfica como esta,
eso \textbf{no} significa que el algoritmo es lineal. Si el tiempo de ejecución
es proporcional a $n^k$ para cualquier exponente $k$, esperaríamos ver
una línea recta con pendiente $k$. Si la pendiente es cercana a 1, eso
sugiere que el algoritmo es lineal. Si es cercana a 2, probablemente sea
cuadrático.

\index{tiempo lineal}
\index{tiempo cuadrático}


\section{Ejercicio 4}
\label{instructions-4}

En el repositorio para este libro encontrarás los archivos de código fuente que
necesitarás para este ejercicio:

\begin{enumerate}

\item
  \java{Profiler.java} contiene la implementación de la clase
  \java{Profiler} descrita anteriormente. Usarás esta clase, aunque no
  tienes que saber cómo funciona. Pero siéntete libre de leer el código.

\item
  \java{ProfileListAdd.java} contiene un código inicial para este ejercicio,
  incluyendo el ejemplo anterior, que perfila
  \java{ArrayList.add}. Modificarás este archivo para perfilar algunos
  otros métodos.

\end{enumerate}

\index{ProfileListAdd}

También, en el directorio \java{code}, encontrarás el archivo de
construcción Ant \java{build.xml}.

Ejecuta \java{ant ProfileListAdd} para correr \java{ProfileListAdd.java}. Deberías
obtener resultados similares a la Figura~\ref{fig-profile1}, pero puede que tengas que
ajustar \java{startN} o \java{endMillis}. La pendiente estimada debería ser cercana
a 1, lo que indica que realizar $n$ operaciones add toma un tiempo proporcional
a $n$ elevada al exponente 1; es decir, está en $O(n)$.

En \java{ProfileListAdd.java}, encontrarás un método vacío llamado
\java{profileArrayListAddBeginning}. Llena el cuerpo de este método
con el código que prueba \java{ArrayList.add}, siempre poniendo el nuevo
elemento al principio. Si inicias con una copia de \java{profileArrayListAddEnd},
deberías tener que hacer unos cuantos cambios. Agrega una línea en
\java{main} para invocar este método.

Ejecuta \java{ant ProfileListAdd} de nuevo e interpreta los resultados. Con base en
nuestro entendimiento de cómo funciona una \java{ArrayList} esperaríamos que cada
operación add fuese lineal, así que el tiempo total para $n$ llamadas a add debería ser
cuadrático. De ser el caso, la pendiente estimada de la línea, en una escala log-log,
debería ser cercana a 2. ¿Lo es?

\index{tiempo lineal}
\index{tiempo cuadrático}

Ahora comparemos estas mediciones con el desempeño de \java{LinkedList}. Llena
el cuerpo de \java{profileLinkedListAddBeginning} y úsalo para clasificar
\java{LinkedList.add} cuando colocamos el nuevo elemento al principio. ¿Qué
desempeño esperaríamos? ¿Son los resultados consistentes con tus expectativas?

\index{LinkedList}

Finalmente, llena el cuerpo de \java{profileLinkedListAddEnd} y úsalo
para clasificar \java{LinkedList.add} cuando colocamos el nuevo elemento al
final. ¿Qué rendimiento esperarías? ¿Son los resultados consistentes con
tus expectativas?

Presentaré los resultados y las respuestas a estas preguntas en el siguiente capítulo.


\chapter{Listas de enlace doble}

Este capítulo revisa los resultados de los ejercicios previos e introduce
otra implementación de la interfaz \java{List}, la lista de enlace doble.

\section{Resultados del perfilado de desempeño}
\label{performance-profiling-results}

\index{perfilado}

En el ejercicio anterior, usamos \java{Profiler.java} para realizar varias
operaciones con \java{ArrayList} y \java{LinkedList} para un rango de
tamaños de problemas. Graficamos los tiempos de ejecución versus el tamaño
del problema en una escala log-log y estimamos la pendiente de la curva
resultante, que indica el exponente predominante de la relación entre tiempo
de ejecución y tamaño del problema.

\index{Profiler}
\index{add}
\index{tiempo promedio}

Por ejemplo, cuando usamos el método \java{add} para agregar elementos
al final de una \java{ArrayList}, encontramos que el tiempo total para llevar a
cabo $n$ llamadas a add era proporcional a $n$; es decir, la pendiente
estimada era cercana a 1. Concluimos que completar $n$ llamadas a add
está en $O(n)$, así que en promedio el tiempo para una llamada a add es de
tiempo constante, o $O(1)$, que es lo que esperaríamos con base en el análisis
de los algoritmos.

\index{tiempo constante}

% NOTE: Again, Patrick is concerned that my use of ``average'' might
% be confusing, but I think it's reasonable to describe amortized
% analysis as an average over a series of operations.

El ejercicio te pedía llenar el cuerpo de
\java{profileArrayListAddBeginning}, que prueba el desempeño de
agregar nuevos elementos al principio de una \java{ArrayList}. Con base en
nuestro análisis, esperábamos que add fuera lineal, porque tiene que desplazar
los otros elementos a la derecha; así que esperaríamos que $n$ llamadas a add
sean cuadráticas.

\index{tiempo cuadrático}
\index{tiempo lineal}

Aquí está una solución, que puedes encontrar en
el directorio {\tt solution} del repositorio.

\begin{verbatim}
    public static void profileArrayListAddBeginning() {
        Timeable timeable = new Timeable() {
            List<String> list;

            public void setup(int n) {
                list = new ArrayList<String>();
            }

            public void timeMe(int n) {
                for (int i=0; i<n; i++) {
                    list.add(0, "a string");
                }
            }
        };
        int startN = 4000;
        int endMillis = 10000;
        runProfiler("ArrayList add beginning", timeable, startN, endMillis);
    }
\end{verbatim}

Este método es casi idéntico a \java{profileArrayListAddEnd}. La
única diferencia está en \java{timeMe}, que usa la versión de dos
parámetros de \java{add} para colocar el nuevo elemento en el índice 0. También,
incrementos \java{endMillis} para obtener un punto de datos adicional.

Aquí están los resultados de las mediciones (tamaño del problema a la
izquierda, tiempo de ejecución en milisegundos a la derecha):

\begin{verbatim}
4000, 14
8000, 35
16000, 150
32000, 604
64000, 2518
128000, 11555
\end{verbatim}

La figura~\ref{fig-profile2}
muestra la gráfica de tiempo de ejecución versus tamaño del problema.
\index{problem size}

\begin{figure}
\centering
\includegraphics[height=2.5in]{figs/profile2.png}
\caption{Resultados del perfilado: tiempo de ejecución versus tamaño del problema para agregar
$n$ elementos al principio de una \java{ArrayList}.}
\label{fig-profile2}
\end{figure}

Recuerda que una línea recta en esta gráfica \textbf{no} significa que
el algoritmo es lineal. En su lugar, si el tiempo de ejecución es proporcional a
$n^k$ para cualquier exponente, $k$, esperaríamos ver una línea recta
con pendiente $k$. En este caso, esperaríamos que el tiempo total para $n$ llamadas a
add sea proporcional a $n^2$, así que esperaríamos una línea recta con pendiente
2. De hecho, la pendiente estimada es 1.992, que se acerca tanto que me daría
temor falsificar datos tan buenos.

\index{perfilado}


\section{Perfilado de los métodos de \java{LinkedList}}
\label{profiling-linkedlist-methods}

En el ejercicio anterior también perfilaste el desempeño de agregar nuevos
elementos al principio de una \java{LinkedList}. Con base en nuestro
análisis, esperaríamos que cada llamada a \java{add} tomara tiempo constante,
porque en una lista enlazada, no tenemos que desplazar los elementos existentes;
podemos simplemente agregar un nuevo nodo al principio. Así que esperaríamos
que el tiempo total para $n$ llamadas a add fuese lineal.

\index{tiempo constante}
\index{tiempo lineal}
\index{LinkedList}

Aquí está una solución:

\begin{verbatim}
    public static void profileLinkedListAddBeginning() {
        Timeable timeable = new Timeable() {
            List<String> list;

            public void setup(int n) {
                list = new LinkedList<String>();
            }

            public void timeMe(int n) {
                for (int i=0; i<n; i++) {
                    list.add(0, "a string");
                }
            }
        };
        int startN = 128000;
        int endMillis = 2000;
        runProfiler("LinkedList add beginning", timeable, startN, endMillis);
    }
\end{verbatim}

Tenemos que hacer unos cuantos cambios, reemplazando
\java{ArrayList} con \java{LinkedList} y ajustando
\java{startN} y \java{endMillis} para obtener un buen rango de datos.
Las mediciones contenían más ruido que el anterior intento; aquí están
los resultados:

\begin{verbatim}
128000, 16
256000, 19
512000, 28
1024000, 77
2048000, 330
4096000, 892
8192000, 1047
16384000, 4755
\end{verbatim}

La figura~\ref{fig-profile3}
muestra la gráfica de estos resultados.

\begin{figure}
\centering
\includegraphics[height=2.5in]{figs/profile3.png}
\caption{Resultados del perfilado: tiempo de ejecución versus tamaño del problema para
agregar $n$ elementos al principio de una \java{LinkedList}.}
\label{fig-profile3}
\end{figure}

No es una línea muy recta, y la pendiente no es exactamente 1; la pendiente
del ajuste de mínimos cuadrados es 1.23. Pero estos resultados indican que
el tiempo total para $n$ llamadas a add es por lo menos aproximadamente $O(n)$,
así que cada llamada a add es de tiempo constante.

\index{tiempo constante}

\section{Agregar al final de una \java{LinkedList}}
\label{adding-to-the-end-of-a-linkedlist}

Agregar elementos al principio es una de las operaciones donde
esperamos que \java{LinkedList} sea más rápida que \java{ArrayList}. Pero para
agregar elementos al final, esperamos que \java{LinkedList} sea más lenta.
En mi implementación, tenemos que recorrer la lista completa para agregar
un elemento al final, lo que es lineal. Así que esperamos que el tiempo total
para $n$ llamadas a add sea cuadrático.

\index{tiempo cuadrático}
\index{tiempo lineal}
\index{LinkedList}
\index{add}

Bien, no lo es. Aquí está el código:

\begin{verbatim}
    public static void profileLinkedListAddEnd() {
        Timeable timeable = new Timeable() {
            List<String> list;

            public void setup(int n) {
                list = new LinkedList<String>();
            }

            public void timeMe(int n) {
                for (int i=0; i<n; i++) {
                    list.add("a string");
                }
            }
        };
        int startN = 64000;
        int endMillis = 1000;
        runProfiler("LinkedList add end", timeable, startN, endMillis);
    }
\end{verbatim}

Aquí están los resultados:

\begin{verbatim}
64000, 9
128000, 9
256000, 21
512000, 24
1024000, 78
2048000, 235
4096000, 851
8192000, 950
16384000, 6160
\end{verbatim}

La figura~\ref{fig-profile4}
muestra la gráfica de estos resultados.

\begin{figure}
\centering
\includegraphics[height=2.5in]{figs/profile4.png}
\caption{Resultados del perfilado: tiempo de ejecución versus tamaño del problema
para agregar $n$ elementos al final de una \java{LinkedList}.}
\label{fig-profile4}
\end{figure}

\index{perfilado}

De nuevo, las medidas contienen mucho ruido y la línea no es perfectamente
recta, pero la pendiente estimada es 1.19, que es cercana a la que obtuvimos
al agregar elementos al principio, y no muy cercana a 2, que es lo que
esperábamos con base en nuestro análisis. De hecho, es más cercana a
1, lo que sugiere que agregar elementos al final es de tiempo constante.
¿Qué está sucediendo?

\index{tiempo constante}

\section{Lista de enlace doble}
\label{doubly-linked-list}

Mi implementación de una lista enlazada, \java{MyLinkedList}, usa una
lista de enlace sencillo; es decir, cada elemento contiene un enlace al siguiente
y el objeto \java{MyArrayList} en sí mismo tiene un enlace al primer nodo.

\index{lista de enlace doble}
\index{LinkedList}

Pero si lees la documentación de \java{LinkedList} en
\url{http://thinkdast.com/linked},
dice:

\begin{quote}
Implementación de lista de enlace doble de las interfaces
List y Deque. [\ldots] Todas las operaciones se desempeñan
como podría esperarse de una lista de enlace doble. Las operaciones
provean un índice a la lista recorrerán la lista desde el principio o desde
el final, dependiendo de cuál esté más cerca al índice especificado.
\end{quote}

Si no estás familiarizado con las listas de enlace doble, puedes leer
más sobre ellas en \url{http://thinkdast.com/doublelist}, pero la
versión corta es:

\begin{itemize}
\item
  Cada nodo contiene un enlace al siguiente nodo y un enlace al nodo
  previo.

\item
  El objeto \java{LinkedList} contiene enlaces al primer y último
  elementos de la lista.

\end{itemize}

Así que podemos empezar en cualquier extremo de la lista y recorrerla
en cualquier dirección. Como resultado, ¡podemos agregar y remover
elementos desde el principio y el final de la lista en tiempo constante!

\index{tiempo constante}

La siguiente tabla resume el desempeño que esperaríamos de
\java{ArrayList}, \java{MyLinkedList} (enlace simple), y
\java{LinkedList} (enlace doble):

\begin{tabular}[c]{@{}llll@{}}
\hline
& MyArrayList & MyLinkedList & LinkedList
\\
\hline
add (al final) & \textbf{1} & n & \textbf{1}
\\
add (al principio) & n & \textbf{1} & \textbf{1}
\\
add (en general) & n & n & n
\\
get / set & \textbf{1} & n & n
\\
indexOf / lastIndexOf & n & n & n
\\
isEmpty / size & 1 & 1 & 1
\\
remove (del final) & \textbf{1} & n & \textbf{1}
\\
remove (del principio) & n & \textbf{1} & \textbf{1}
\\
remove (en general) & n & n & n
\\
\hline
\end{tabular}


\section{Elección de una estructura}

La implementación de enlace doble es mejor que \java{ArrayList} para
agregar y remover al principio e igual de buena que
\java{ArrayList} para agregar y remover al final. Así que la única
ventaja de \java{ArrayList} es para \java{get} y \java{set},
que requieren tiempo lineal en una lista enlazada, incluso si es de enlace doble.

\index{tiempo lineal}
\index{selección de una estructura de datos}
\index{elección de una estructura de datos}

Si sabes que el tiempo de ejecución de tu aplicación depende del tiempo
que toma obtener (\java{get}) o modificar (\java{set}) los elementos,
una \java{ArrayList} podría ser la mejor opción. Si el tiempo de ejecución depende de
agregar y remover elementos cerca del principio o del final, \java{LinkedList}
podría ser mejor.

\index{orden de crecimiento}
\index{tiempo constante}

Pero recuerda que estas recomendaciones se basan en la orden de crecimiento
para problemas grandes. Hay otros factores a considerar:

\begin{itemize}

\item
  Si estas operaciones no requieren una fracción sustancial del tiempo
  de ejecución para tu aplicación --- es decir, si tu aplicación pasa la
  mayor parte de su tiempo haciendo otras cosas --- entonces tu elección
  de una implementación de \java{List} no importará mucho.

\item
  Si las listas con las que estás trabajando no son muy grandes, podría ser
  que no obtengas el desempeño que esperas. Para problemas pequeños, un
  algoritmo cuadrático podría ser más rápido que un algoritmo lineal, o un algoritmo
  lineal podría ser más rápido que uno de tiempo constante. Y para problemas
  pequeños, la diferencia probablemente no es importante.

\item
  También, no olvides el espacio. Hasta el momento nos hemos enfocado en el
  tiempo de ejecución, pero diferentes implementaciones requieren diferentes
  cantidades de espacio. En una \java{ArrayList}, los elementos se guardan uno a
  la par de otro en un trozo de la memoria, así que hay poco espacio
  desperdiciado y el hardware de la computadora es más rápido con trozos
  contiguos. En una lista enlazada, cada elemento requiere un nodo con uno o dos
  enlaces. Los enlaces ocupan espacio (¡a veces más que los datos!), y con nodos
  dispersos por todas partes en la memoria, el hardware podría ser menos eficiente.

\end{itemize}

En resumen, el análisis de algoritmos provee algunas guías para elegir entre
estructuras de datos, pero solo si

\begin{enumerate}

\item
  El tiempo de ejecución de tu aplicación es importante,

\item
  El tiempo de ejecución de tu aplicación depende de la elección de una estructura
  de datos y

\item
  El tamaño del problema es lo suficientemente grande para que el orden de crecimiento
  realmente prediga cuál estructura de datos es mejor.

\end{enumerate}

Podrías tener una larga carrera como ingeniero de software y nunca encontrarte
en esta situación.


\chapter{Recorrido de árboles}
\label{cs-traversing-trees}

Este capítulo introduce la aplicación que desarrollaremos durante el
resto del libro, un motor de búsqueda web.
Describo los elementos de un motor de búsqueda e
introduzco la primera aplicación, un rastreador Web que descarga e interpreta
páginas de Wikipedia.  Este capítulo también presenta una implementación
recursiva de la búsqueda en profundidad y una implementación iterativa que usa
una \java{Deque} de java para implementar una pila ``último en entrar, primero en salir''.

\index{Deque}

\section{Motores de búsqueda}
\label{the-road-ahead}

Un \textbf{motor de búsqueda web}, como Google Search o Bing, toma un conjunto
de ``términos de búsqueda'' y devuelve una lista de páginas web que son relevantes
para esos términos (explicaré más tarde lo que significa ``relevante'').  Puedes leer
más en \url{http://thinkdast.com/searcheng}, pero explicaré lo que necesites conforme
que avancemos.

\index{motor de búsqueda}
\index{término de búsqueda}
\index{rastreador}
\index{indexador}
\index{recuperador}

Los componentes esenciales de un motor de búsqueda son:

\begin{itemize}

\item
  Rastrear: Necesitaremos un programa que pueda descargar una página, interpretarla
  y extraer el texto y cualquier enlace a otras páginas.

\item
  Indexar: Necesitaremos una estructura de datos que haga posible buscar un término
  de búsqueda y encontrar las páginas que lo contienen.

\item
  Recuperar: Y necesitaremos una forma de recolectar los resultados del Índice e identificar
  las páginas que son más relevantes para los términos de búsqueda.

\end{itemize}

Comenzaremos con el rastreador. La meta de un rastreador es descubrir y
descargar un conjunto de páginas web. Para motores de búsqueda como Google
y Bing, la meta es encontrar \emph{todas} las páginas web, pero muchas veces los
rastreadores están limitados a un dominio más pequeño. En nuestro caso, sólo leeremos
páginas de Wikipedia.

\index{Wikipedia}
\index{Llegar a la filosofía}

Como un primer paso, construiremos un rastreador que lea una página de Wikipedia,
encuentre el primer enlace, siga un enlace a otra página y repita el proceso. Usaremos
este rastreador para comprobar la conjetura ``Llegar a la Filosofía'', que establece:

\begin{quote}
Al hacer clic en el primer enlace en minúsculas en el texto principal de un artículo de
Wikipedia, y luego repetir el proceso para artículos subsiguientes, por lo general
eventualmente te conducirá al artículo sobre Filosofía.
\end{quote}

La conjetura se establece en
\url{http://thinkdast.com/getphil}{},
y puedes leer su historia ahí.

Probar la conjetura nos permitirá construir las piezas básicas de un
rastreador sin tener que rastrear toda la web, o incluso toda
Wikipedia. ¡Y pienso que el ejercicio es algo divertido!

En unos cuantos capítulos, trabajaremos en el indexador, y luego en
el recuperador.

\section{Interpretación del HTML}
\label{parsing-html}

Cuando descargas una página web, los contenidos se escriben en
el Lenguaje de Marcas de Hipertexto, también conocido como HTML.
Por ejemplo, aquí está un documento de HTML con los contenidos mínimos:

\begin{verbatim}
<!DOCTYPE html>
<html>
  <head>
    <title>This is a title</title>
  </head>
  <body>
    <p>Hello world!</p>
  </body>
</html>
\end{verbatim}

Las frases ``This is a title'' y ``Hello world!'' son el texto que
de hecho aparece en la página; los otros elementos son \textbf{etiquetas} que
indican cómo debería mostrarse el texto.

\index{HTML}
\index{etiqueta}
\index{jsoup}
\index{interpretación}

Cuando nuestro rastreador descarga una página, necesitará interpretar el HTML
para extraer el texto y encontrar los enlaces. Para hacerlo, usaremos
\textbf{jsoup}, que es una biblioteca de Java de código abierto que descarga e
interpreta HTML.

\index{árbol DOM}

El resultado de interpretar HTML es un árbol de Modelo de Objeto de Documento (DOM) o
\textbf{árbol DOM}, que contiene los elementos de un documento, incluyendo texto y
etiquetas. El árbol es una estructura de datos enlazada formada por nodos; los
nodos representan texto, etiquetas y otros elementos del documento.

\index{raíz}
\index{nodo hijo}

Las relaciones entre los nodos son determinadas por la estructura del
documento. En el ejemplo anterior, el primer nodo, llamado la
\textbf{raíz}, es la etiqueta \java{<html>}, la cual
contiene enlaces a los dos nodos que contiene,
\java{<head>} y
\java{<body>}; estos nodos son los
\textbf{hijos} del nodo raíz.

El nodo \java{<head>} tiene un hijo,
\java{<title>}, y el nodo
\java{<body>} tiene un hijo,
\java{<p>} (que significa ``párrafo''). 
La figura~\ref{fig-dom1}
 representa este árbol gráficamente.

\begin{figure}
\centering
\includegraphics[height=2.5in]{figs/dom_tree1.pdf}
\caption{Árbol DOM para una página HTML simple.}
\label{fig-dom1}
\end{figure}


Cada nodo contiene enlaces a sus hijos; además, cada nodo
contiene un enlace a su \textbf{padre}, así que desde cualquier nodo es posible
navegar hacia arriba y hacia abajo en el árbol. El árbol DOM para páginas web reales
usualmente es más complicado que este ejemplo.

\index{nodo padre}
\index{inspección del DOM}

La mayoría de los navegadores web proveen herramientas para inspeccionar el DOM de
la página que estás viendo. En Chrome, puedes hacer clic derecho sobre cualquier parte
de una página web y seleccionar ``Inspeccionar'' desde el menú emergente. En Firefox,
puedes hacer clic derecho y seleccionar ``Inspeccionar Elemento'' del menú. Safari
provee una herramienta llamada Inspector Web, sobre la que puedes leer en
\url{http://thinkdast.com/safari}.
Para Internet Explorer, puedes leer las instrucciones en
\url{http://thinkdast.com/explorer}.

\begin{figure}
\centering
\includegraphics[height=2.5in]{figs/DOMinspector.png}
\caption{Captura de pantalla del Inspector DOM de Chrome.}
\label{fig-dom2}
\end{figure}

La figura~\ref{fig-dom2}
muestra una captura de pantalla del DOM para la página de Wikipedia en Java,
\url{http://thinkdast.com/java}.
El elemento que está resaltado es el primer párrafo del texto principal
del artículo, que está contenido dentro de un
elemento \java{<div>} con
\java{id="mw-content-text"}. Usaremos el id de este elemento para identificar el
texto principal de cada artículo que descarguemos.

\index{elemento}



\section{Uso de jsoup}
\label{using-jsoup}

jsoup facilita descargar e interpretar páginas web y para navegar el árbol
DOM. Aquí está un ejemplo:

\begin{verbatim}
    String url = "http://en.wikipedia.org/wiki/Java_(programming_language)";

    // descarga e interpreta el documento
    Connection conn = Jsoup.connect(url);
    Document doc = conn.get();

    // selecciona el texto del contenido y extráelo de los párrafos.
    Element content = doc.getElementById("mw-content-text");
    Elements paragraphs = content.select("p");
\end{verbatim}

\java{Jsoup.connect} toma una URL como una \java{String} y se conecta al
servidor web; el método \java{get} descarga el HTML, lo interpreta,
y devuelve un objeto \java{Document}, que representa el DOM.

\index{jsoup}
\index{Document}

\java{Document} provee métodos para navegar por el árbol y
seleccionar nodos. De hecho, provee tantos métodos, que puede ser
confuso. Este ejemplo demuestra dos formas de seleccionar nodos:

\begin{itemize}

\item
  \java{getElementById} toma una \java{String} y busca un elemento en el árbol
  que tenga un campo ``id'' que coincida. Aquí selecciona el nodo
  \java{<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">},
  que aparece en cada página de Wikipedia para identificar el elemento
  \java{<div>} que contiene el texto principal de la página, en oposición
  a la barra de navegación y otros elementos.

  El valor de retorno de \java{getElementById} es un objeto \java{Element}
  que representa este \java{<div>} y contiene los elementos en el \java{<div>}
  como hijos, nietos, etc.

\item
  \java{select} toma una \java{String}, recorre el árbol y devuelve todos
  los elementos con etiquetas que coincidan con la \java{String}. En este
  ejemplo, devuelve todos los párrafos que aparecen en \java{content}. El
  valor de retorno es un objeto {Elements}.

\end{itemize}

\index{select}
\index{Node}
\index{Element}

Antes de continuar, deberías dar una ojeada a la documentación de estas clases para
que sepas lo que pueden hacer. Las clases más importantes son
\java{Element}, \java{Elements}, y \java{Node}, sobre las que puedes leer en
\url{http://thinkdast.com/jsoupelt},
\url{http://thinkdast.com/jsoupelts} y
\url{http://thinkdast.com/jsoupnode}.

\java{Node} representa un nodo en el árbol DOM; hay varias
subclases que extienden \java{Node}, incluyendo 
\java{Element}, \java{TextNode}, \java{DataNode} y \java{Comment}.
\java{Elements} es una \java{Collection} de objetos \java{Element}.

\index{subclase}

\begin{figure}
\centering
\includegraphics[width=5in]{figs/yuml2.pdf}
\caption{Diagrama UML para clases seleccionadas provistas por jsoup.}
\label{fig-uml2}
% Edit: http://yuml.me/edit/4bc1c919
\end{figure}

La figura~\ref{fig-uml2} es un diagrama UML que muestra las relaciones entre
estas clases. En un diagrama de clases UML, una línea con una cabeza de flecha
vacía indica que una clase extiende a la otra. Por ejemplo, este
diagrama indica que \java{Elements} extiende \java{ArrayList}.
Volveremos a los diagramas UML en la Sección~\ref{uml-class-diagrams}.

\index{diagrama UML}


\section{Recorriendo el DOM}
\label{iterating-through-the-dom}

Para facilitarte la vida, proveo una clase llamada
\java{WikiNodeIterable} que te permite recorrer los nodos en un
árbol DOM. Aquí está un ejemplo que muestra cómo usarlo:

\index{WikiNodeIterable}

\begin{verbatim}
    Elements paragraphs = content.select("p");
    Element firstPara = paragraphs.get(0);

    Iterable<Node> iter = new WikiNodeIterable(firstPara);
    for (Node node: iter) {
        if (node instanceof TextNode) {
            System.out.print(node);
        }
    }
\end{verbatim}

Este ejemplo continúa donde finalizó el anterior. Selecciona el
primer párrafo en \java{paragraphs} y luego crea un
\java{WikiNodeIterable}, que implementa
\java{Iterable<Node>}. 
\java{WikiNodeIterable} realiza una ``búsqueda en profundidad'', que
produce los nodos en el orden que aparecerían en la página.

\index{búsqueda en profundidad}
\index{TextNode}

En este ejemplo, imprimimos un \java{Node} solo si es un
\java{TextNode} e ignoramos otros tipos de \java{Node}, específicamente
los objetos \java{Element} que representan etiquetas. El resultado es el
texto plano del párrafo HTML sin ninguna marca. La salida es:

\begin{quote}
Java is a general-purpose computer programming language that is
concurrent, class-based, object-oriented,{[}13{]} and specifically
designed \ldots
\end{quote}


\section{Búsqueda en profundidad}
\label{depth-first-search}

Hay varias maneras en las que podrías razonablemente recorrer un árbol, cada una
con diferentes aplicaciones. Comenzaremos con ``búsqueda en profundidad'', o
DFS (por sus siglas en inglés, \emph{depth-first search}). DFS comienza en la raíz
del árbol y selecciona el primer hijo. Si el hijo tiene hijos, selecciona el primer hijo de
nuevo. Cuando llega a un nodo sin hijos, se regresa, moviéndose hacia arriba en el
árbol al nodo padre, donde selecciona al siguiente hijo si hay uno; de otra manera
se regresa de nuevo. Cuando ha explorado el último hijo de la raíz, finaliza.

\index{DFS}
\index{recursión}

Hay dos formas comunes de implementar DFS, recursivamente e iterativamente.
La implementación recursiva es simple y elegante:

\begin{verbatim}
private static void recursiveDFS(Node node) {
    if (node instanceof TextNode) {
        System.out.print(node);
    }
    for (Node child: node.childNodes()) {
        recursiveDFS(child);
    }
}
\end{verbatim}

Este método se invoca en cada \java{Node} en el árbol, comenzando
con la raíz. Si el \java{Node} que se devuelve es un \java{TextNode}, se
imprimen sus contenidos. Si el \java{Node} tiene hijos, se invoca
\java{recursiveDFS} en cada uno de ellos en orden.

\index{recorrido de un árbol}
\index{pre orden}
\index{post orden}
\index{en orden}

En este ejemplo, imprimimos los contenidos de cada \java{TextNode} antes
de recorrer los hijos, así que este es un ejemplo de un recorrido
``pre orden''. Puedes leer sobre los recorridos ``pre orden'', ``post orden''
y ``en orden'' en \url{http://thinkdast.com/treetrav}.  Para esta aplicación
el orden del recorrido no importa.

\index{pila de llamadas}

Al realizar llamadas recursivas, \java{recursiveDFS} usa la pila de llamadas
(\url{http://thinkdast.com/callstack}) para llevar el control
de los nodos hijos y procesarlos en el orden correcto. Como una
alternativa, podemos usar una estructura de datos pila para llevar
el control de los nodos nosotros mismos; si hacemos eso, podemos evitar
la recursión y recorrer el árbol iterativamente.


\section{Pilas (Stacks) en Java}
\label{stacks-in-java}

Antes de explicar la versión iterativa de DFS, explicaré
la estructura de datos pila. Comenzaremos con el concepto general
de una pila, a la que llamaré una ``pila'' en minúsculas y en español.
Luego hablaremos sobre dos \java{interfaces} de Java que definen los
métodos de una pila: \java{Stack} y \java{Deque}.

\index{Stack}
\index{Deque}

% TODO: introduce the term ``Abstract Data Type''?

Una pila es una estructura de datos que es similar a una lista: es una
colección que mantiene el orden de los elementos. La principal
diferencia entre una pila y una lista es que una pila provee menos
métodos. En la convención usual, provee:

\begin{itemize}

\item
  \java{push}: que agrega un elemento a la parte superior de la pila.

\item
  \java{pop}: que remueve y devuelve el elemento de la parte superior de la pila.

\item
  \java{peek}: que devuelve el elemento de la parte superior sin modificar
  la pila.

\item
  \java{isEmpty}: que indica si la pila está vacía.

\end{itemize}

Porque \java{pop} siempre devuelve el elemento de la parte superior, una pila
también es conocida como una ``UEPS'', que significa ``ultimo en entrar, primero
en salir''. Una alternativa a una pila es una ``cola'', que devuelve elementos en el
mismo orden que son añadidos, es decir, ``primero en entrar, primero en salir''
o PEPS.

\index{push}
\index{pop}
\index{peek}
\index{isEmpty}
\index{PEPS}
\index{UEPS}
\index{pila}
\index{cola}

Podría no ser obvio por qué las pilas y las colas son útiles: no proveen
ninguna operación que no provean las listas; de hecho proveen
menos operaciones. Así que, ¿por qué no usar las listas para todo? Hay
dos razones:

\begin{enumerate}

\item
  Si te limitas tú mismo a un pequeño conjunto de métodos --- es decir,
  una API pequeña --- tu código será más legible y menos propenso a
  errores. Por ejemplo, si usas una lista para representar una pila, podrías
  accidentalmente remover un elemento en el orden incorrecto. Con la API
  pila, esta clase de error es literalmente imposible. Y la mejor manera para
  evitar errores es hacerlos imposibles.

\item
  Si una estructura de datos provee una API pequeña, es más fácil de
  implementar eficientemente. Por ejemplo, una manera simple de
  implementar una pila es con una lista de enlace sencillo. Cuando
  agregamos (push) un elemento a la pila, lo agregamos al principio
  de la lista; cuando removemos (pop) un elemento, lo removemos del
  principio. Para una lista enlazada, agregar y remover desde el principio
  son operaciones de tiempo constante, así que esta implementación es
  eficiente. De forma similar, las APIs grandes son más difíciles de
  implementar eficientemente.

\end{enumerate}

\index{tiempo constante}

Para implementar una pila en Java, tienes tres opciones:

\begin{enumerate}

\item
  Adelante, usa  \java{ArrayList} o \java{LinkedList}. Si usas
  \java{ArrayList}, asegúrate de agregar y remover desde el \emph{final},
  que es una operación de tiempo constante. Y ten el cuidado de no agregar
  elementos en el lugar equivocado o removerlos en el orden equivocado,

\item
  Java provee una clase llamada \java{Stack} que provee el conjunto estándar
  de métodos de una pila. Pero esta clase es una parte antigua de Java: no es
  consistente con el Java Collections Framework, que vino después.

\item
  Probablemente la mejor opción es usar uno de las implementaciones de la
  interfaz \java{Deque}, como \java{ArrayDeque}.

\end{enumerate}

``Deque'' significa ``double-ended queue'' (``cola con dos extremos''); se supone que
se pronuncia ``deck'', pero algunos dicen ``deek''. En Java, la
interfaz \java{Deque} provee \java{push}, \java{pop},
\java{peek}, y \java{isEmpty}, así que puedes usar una \java{Deque} como
una pila. Provee otros métodos, sobre los que puedes leer en
\url{http://thinkdast.com/deque},
pero no los usaremos por ahora.

\index{deque}


\section{DFS Iterativa}
\label{iterative-dfs}

Aquí está una versión iterativa de DFS que usa una \java{ArrayDeque} para
representar una pila de objetos \java{Node}:

\begin{verbatim}
    private static void iterativeDFS(Node root) {
        Deque<Node> stack = new ArrayDeque<Node>();
        stack.push(root);

        while (!stack.isEmpty()) {
            Node node = stack.pop();
            if (node instanceof TextNode) {
                System.out.print(node);
            }

            List<Node> nodes = new ArrayList<Node>(node.childNodes());
            Collections.reverse(nodes);

            for (Node child: nodes) {
                stack.push(child);
            }
        }
    }
\end{verbatim}

El parámetro, \java{root}, es la raíz del árbol que queremos
recorrer, así que comenzamos por crear la pila y agregar la raíz en ella.

\index{ArrayDeque}
\index{DFS iterativa}


El bucle continúa hasta que la pila está vacía. En cada repetición, se
remueve un \java{Node} de la pila. Si se obtiene un \java{TextNode}, se imprimen
los contenidos. Entonces se agregan a sus hijos en la pila. Para
procesar a los hijos en el orden correcto, tenemos que agregarlos al stack
en orden inverso; hacemos eso al copiar los hijos en una 
\java{ArrayList}, invertimos los elementos en sitio y luego iteramos
a través de la \java{ArrayList} invertida.

Una ventaja de la versión iterativa de DFS es que es más fácil de
implementar como un \java{Iterator} de Java; verás cómo en el siguiente
capítulo.

\index{LinkedList}

Pero antes, un último comentario sobre la interfaz \java{Deque}: además
de \java{ArrayDeque}, Java provee otra implementación de
\java{Deque}, nuestra vieja amiga \java{LinkedList}. \java{LinkedList}
implementa ambas interfaces, \java{List} y \java{Deque}. La interfaz
que obtendrás depende de cómo la uses. Por ejemplo, si asignas
un objeto \java{LinkedList} a una variable \java{Deque}, así:

\begin{verbatim}
Deqeue<Node> deque = new LinkedList<Node>();
\end{verbatim}

puedes usar los métodos de la interfaz \java{Deque}, pero ningún
método de la interfaz \java{List}. Si asignas una variable
\java{List}, como esta:

\begin{verbatim}
List<Node> deque = new LinkedList<Node>();
\end{verbatim}

puedes usar los métodos de \java{List} pero ninguno de los métodos de \java{Deque}.
Y si la asignas así:

\begin{verbatim}
LinkedList<Node> deque = new LinkedList<Node>();
\end{verbatim}

puedes usar \emph{todos} los métodos. Pero si combinas métodos de
interfaces diferentes, tu código será menos legible y más propenso
a errores.



\chapter{Llegar a la Filosofía}
\label{getphilo}

La meta de este capítulo es desarrollar un rastreador Web para probar
la conjetura ``Llegar a la Filosofía'', que presentamos en la
Sección~\ref{the-road-ahead}.

\index{Llegar a la Filosofía}


\section{Introducción}
\label{getting-started}

En el repositorio para este libro,
encontrarás código base para ayudarte a empezar:

\begin{enumerate}

\item
  \java{WikiNodeExample.java} contiene el código del capítulo
  anterior, demostrando implementaciones recursivas e iterativas de
  la búsqueda en profundidad (DFS) en un árbol DOM.

\item
  \java{WikiNodeIterable.java} contiene una clase \java{Iterable} para
  recorrer un árbol DOM: Explicaré este código en la siguiente sección.

\item
  \java{WikiFetcher.java} contiene una clase utilitaria que usa jsoup para
  descargar páginas de Wikipedia. Para ayudarte a cumplir con los términos del
  servicio de Wikipedia, esta clase limita qué tan rápido puedes descargar páginas;
  si solicitas más de una página por segundo, se duerme antes de
  descargar la siguiente página.

\item
  \java{WikiPhilosophy.java} contiene un boceto del código que escribirás
  para este ejercicio. Lo revisaremos en breve.

\end{enumerate}

También encontrarás el archivo de construcción Ant
\java{build.xml}.  Si escribes \java{ant WikiPhilosophy}, se ejecutará
un fragmento de código inicial.

\index{WikiPhilosophy}
\index{Ant}


\section{Iterables e Iterators}
\label{iterables-and-iterators}

En el capítulo anterior, presenté una búsqueda en profundidad
iterativa (DFS), y sugerí que una ventaja de la versión iterativa,
comparada a la versión recursiva, es que es más fácil de envolver en
un objeto \java{Iterator}. En esta sección, veremos cómo hacer eso.

\index{Iterable}
\index{Iterator}

Si no estás familiarizado con las interfaces \java{Iterator} y
\java{Iterable}, puedes leer sobre ellas en
\url{http://thinkdast.com/iterator}
y
\url{http://thinkdast.com/iterable}.

Observa los contenidos de \java{WikiNodeIterable.java}. La clase más
externa, \java{WikiNodeIterable} implementa la
interfaz \java{Iterable<Node>} para que podamos usarla en
un bucle for de la siguiente forma:

\begin{verbatim}
    Node root = ...
    Iterable<Node> iter = new WikiNodeIterable(root);
    for (Node node: iter) {
        visit(node);
    }
\end{verbatim}

donde \java{root} es la raíz del árbol que queremos recorrer y
\java{visit} es un método que hace lo que queramos cuando ``visitamos''
un \java{Node}.

\index{WikiNodeIterable}

La implementación de \java{WikiNodeIterable} sigue una fórmula
convencional:

\begin{enumerate}

\item
  El constructor toma y guarda una referencia al \java{Node} raíz.

\item
  El método \java{iterator} crea y devuelve un objeto \java{Iterator}.

\end{enumerate}

Así es como se ve:

\begin{verbatim}
public class WikiNodeIterable implements Iterable<Node> {

    private Node root;

    public WikiNodeIterable(Node root) {
        this.root = root;
    }

    @Override
    public Iterator<Node> iterator() {
        return new WikiNodeIterator(root);
    }
}
\end{verbatim}

La clase más interna, \java{WikiNodeIterator}, hace todo el trabajo:

\begin{verbatim}
    private class WikiNodeIterator implements Iterator<Node> {

        Deque<Node> stack;

        public WikiNodeIterator(Node node) {
            stack = new ArrayDeque<Node>();
            stack.push(root);
        }

        @Override
        public boolean hasNext() {
            return !stack.isEmpty();
        }

        @Override
        public Node next() {
            if (stack.isEmpty()) {
                throw new NoSuchElementException();
            }

            Node node = stack.pop();
            List<Node> nodes = new ArrayList<Node>(node.childNodes());
            Collections.reverse(nodes);
            for (Node child: nodes) {
                stack.push(child);
            }
            return node;
        }
    }
\end{verbatim}

\index{WikiNodeIterator}
\index{DFS}
\index{búsqueda en profundidad}

Este código es casi idéntico a la versión iterativa de DFS, pero ahora
se divide en tres métodos:

\begin{enumerate}

\item
  El constructor inicializa la pila (que se implementa usando una
  \java{ArrayDeque}) y agrega el nodo raíz a dicha pila.

\item
  \java{isEmpty} comprueba si la pila está vacía.

\item
  \java{next} remueve (pop) el siguiente \java{Node} de la pila, agrega (push) sus
  hijos en orden inverso y devuelve el \java{Node} que removió. Si
  alguien invoca \java{next} en un \java{Iterator} vacío, lanza
  una excepción.

\end{enumerate}

Podría no ser obvio que vale la pena reescribir un método perfectamente
aceptable con dos clases y cinco métodos. Pero ahora que lo hemos
hecho, podemos usar \java{WikiNodeIterable} en cualquier parte que
se llame a un \java{Iterable}, lo que nos hace más fácil y es más limpio desde
un punto de vista sintáctico, separar la lógica de iteración (DFS) de cualquier
otro proceso que estemos haciendo en los nodos.

\index{isEmpty}
\index{next}


\section{\java{WikiFetcher}}
\label{wikifetcher}

\index{WikiFetcher}

Cuando escribes un rastreador Web, es fácil descargar muchas páginas muy
rápido, lo que podría violar los términos del servicio para el servidor
del que estás realizando las descargas. Para evitar esto, proveo una clase
llamada \java{WikiFetcher} que hace dos cosas:

\begin{enumerate}

\item
  Encapsula el código que mostramos en el capítulo previo para descargar
  páginas de Wikipedia, interpretar el HTML, y seleccionar el texto
  del contenido.

\item
  Mide el tiempo entre solicitudes y, si no hemos dejado pasar suficiente
  tiempo entre solicitudes, duerme hasta que ha pasado un intervalo
  razonable. Por defecto, el intervalo es un segundo.

\end{enumerate}

Aquí está la definición de \java{WikiFetcher}:

\begin{verbatim}
public class WikiFetcher {
    private long lastRequestTime = -1;
    private long minInterval = 1000;

    /**
     * Recupera e interpreta una cadena URL, 
     * devuelve una lista de elementos del párrafo.
     *
     * @param url
     * @return
     * @throws IOException
     */
    public Elements fetchWikipedia(String url) throws IOException {
        sleepIfNeeded();

        Connection conn = Jsoup.connect(url);
        Document doc = conn.get();
        Element content = doc.getElementById("mw-content-text");
        Elements paragraphs = content.select("p");
        return paragraphs;
    }

    private void sleepIfNeeded() {
        if (lastRequestTime != -1) {
            long currentTime = System.currentTimeMillis();
            long nextRequestTime = lastRequestTime + minInterval;
            if (currentTime < nextRequestTime) {
                try {
                    Thread.sleep(nextRequestTime - currentTime);
                } catch (InterruptedException e) {
                    System.err.println(
                        "Warning: sleep interrupted in fetchWikipedia.");
                }
            }
        }
        lastRequestTime = System.currentTimeMillis();
    }
}
\end{verbatim}

El único método público es \java{fetchWikipedia}, que toma una URL como
una \java{String} y devuelve una colección \java{Elements} que contiene un
elemento del DOM para cada párrafo en el texto del contenido. Este código
debería resultarle familiar.

\index{Elements}

El nuevo código está es \java{sleepIfNeeded}, que comprueba el tiempo desde
la última solicitud y se duerme si el tiempo transcurrido es menor que
\java{minInterval}, que está en milisegundos.

Eso es todo en \java{WikiFetcher}. Aquí está un ejemplo que demuestra su uso:

\begin{verbatim}
    WikiFetcher wf = new WikiFetcher();

    for (String url: urlList) {
        Elements paragraphs = wf.fetchWikipedia(url);
        processParagraphs(paragraphs);
    }
\end{verbatim}

En este ejemplo, asumimos que \java{urlList} es una colección de
\java{String}s, y \java{processParagraphs} es un método que hace algo
con el objeto \java{Elements} que devuelve \java{fetchWikipedia}.

Este ejemplo demuestra algo importante: deberías crear un
objeto \java{WikiFetcher} y usarlo para manejar todas las solicitudes. Si
tienes múltiples instancias de \java{WikiFetcher}, ellas no forzarán el
intervalo mínimo entre solicitudes.

\index{singleton}

NOTA: Mi implementación de \java{WikiFetcher} es simple, pero sería
fácil para alguien utilizarla incorrectamente al crear múltiples instancias.
Puedes evitar este problema haciendo a \java{WikiFetcher} un ``singleton'',
sobre el que puedes leer más en
\url{http://thinkdast.com/singleton}.


\section{Ejercicio 5}
\label{exercise5}

En \java{WikiPhilosophy.java} encontrarás un método \java{main}
simple que muestra cómo usar algunas de estos fragmentos. Comenzando con
este código, tu trabajo es escribir un rastreador que:

\begin{enumerate}

\item
  Tome una URL para una página de Wikipedia, la descargue y la interprete.

\item
  Debería recorrer el árbol resultante para encontrar el primer
  enlace \emph{válido}. Explicaré lo que significa ``válido'' a continuación.

\item
  Si la página no tiene enlaces, o si el primer enlace es una página que ya
  hemos visto, el programa debería indicar que fracasó y salir.

\item
  Si el enlace coincide con la URL de la página de Wikipedia sobre filosofía,
  el programa debería indicar que tuvo éxito y salir.

\item
  De otra manera debería regresar al Paso 1.

\end{enumerate}

El programa debería construir una \java{List} de las URL que visita y
mostrar los resultados al final (independientemente de si es exitoso o fracasa).

\index{Llegar a la Filosofía}

Entonces, ¿qué deberíamos considerar un enlace``válido''? Tienes algunas opciones.
Varias versiones de la conjetura ``Llegar a la Filosofía'' usan reglas
ligeramente diferentes, pero aquí están algunas opciones:

\begin{enumerate}

\item
  El enlace debería estar en el texto del contenido de la página, no en una
  barra lateral o en un recuadro.

\item
  No debería estar en cursiva o entre paréntesis.

\item
  Deberías omitir enlaces externos, enlaces a la página actual y enlaces
  en rojo.

\item
  En algunas versiones, deberías omitir un enlace si el texto comienza
  con una letra mayúscula.

\end{enumerate}

No tienes que forzar todas estas reglas, pero te recomendamos que al menos
consideres los paréntesis, las cursivas y los enlaces a la página actual.

Si sientes que tienes información para empezar, adelante.
O podrías querer leer estas pistas:

\begin{enumerate}

\item
  Conforme recorras el árbol, las dos clases de \java{Node} que necesitarás
  manejar son \java{TextNode} y \java{Element}. Si encuentras
  un \java{Element}, probablemente tendrás que forzar su conversión a otro tipo
  para acceder a la etiqueta y otra información.

\item
  Cuando encuentres un \java{Element} que contiene un enlace, puedes comprobar
  si está en cursiva siguiendo los enlaces hacia su padre en el árbol. Si hay
  una etiqueta \java{<i>} o \java{<em>} en la cadena de nodos padres, el
  enlace está en cursiva.

\item
  Para comprobar si un enlace está entre paréntesis, tendrás que escanear
  el texto conforme recorras el árbol y llevar el control de los paréntesis
  de apertura y de cierre (idealmente tu solución debería ser capaz de
  manejar paréntesis anidados (como estos)).

\item
  Si comienzas desde la página de Java, deberías llegar a la Filosofía
  después de seguir siete enlaces, a menos que algo haya cambiado desde
  que ejecuté el código.

\end{enumerate}

Muy bien, esa es toda la ayuda que te daré. Ahora te toca a ti.
¡Que te diviertas!



\chapter{Indexador}

Llegados a este punto hemos construido un rastreador Web básico; la siguiente
pieza en la que trabajaremos será el \textbf{índice}. En el contexto de una búsqueda
web, un índice es una estructura de datos que hace posible explorar un término de búsqueda
y encontrar las páginas donde este término aparece. Además, nos gustaría saber
cuántas veces aparece el término de búsqueda en cada página, lo que nos
ayudará a identificar las páginas más relevantes para el término.

\index{índice}
\index{término de búsqueda}

Por ejemplo, si un usuario envía los términos de búsqueda ``programación'' y ``Java'', deberíamos buscar ambos términos y obtener dos conjuntos de
páginas. Las páginas con la palabra ``programación'' incluirían páginas sobre
diferentes lenguajes de programación, así como otros usos de la palabra. 
Las páginas con la palabra ``Java'' incluirían páginas sobre la isla de Java,
el término en inglés para un café y el lenguaje de programación. Al seleccionar
páginas con ambos términos, esperamos eliminar páginas irrelevantes y encontrar
las que tratan sobre programación en Java.

Ahora que entendemos lo que es un índice y las operaciones que
realiza, podemos diseñar una estructura de datos para representarlo.


\section{Selección de una estructura de datos}
\label{data-structure-selection}

La operación fundamental del índice es una \textbf{búsqueda};
específicamente, necesitamos la habilidad de buscar un término y encontrar
todas las páginas que lo contengan. La implementación más simple sería una
colección de páginas. Dado un término de búsqueda, podríamos iterar a través
de los contenidos de las páginas y seleccionar las que contengan el término
de búsqueda Pero el tiempo de ejecución sería proporcional al número total
de palabras en todas las páginas, lo que sería súper lento.

\index{búsqueda}
\index{mapa}
\index{par clave-valor}
\index{clave}
\index{valor}
\index{frecuencia}

Una mejor alternativa es un \textbf{mapa}, que es una estructura de datos que
representa una colección de \textbf{pares clave-valor} y provee una forma
rápida de buscar una \textbf{clave} y encontrar el \textbf{valor} correspondiente.
Por ejemplo, el primer mapa que construiremos es un \java{TermCounter} (contador
de términos), que mapea cada término de búsqueda al número de veces que aparece
en una página. Las claves son los términos de búsqueda y los valores son los
conteos (también llamados ``frecuencias'').

Java provee una interfaz llamada \java{Map} que especifica los métodos
que un mapa debe proveer; los más importantes son:

\begin{itemize}

\item
  \java{get(key)}: Este método busca una clave (key) y devuelve el
  valor (value) correspondiente.

\item
  \java{put(key, value)}: Este método agrega un nuevo par clave-valor al
  \java{Map}, o si la clave ya está en el mapa, reemplaza el valor asociado con \java{key}.

\end{itemize}

Java provee varias implementaciones de \java{Map}, incluyendo las dos en
la que nos enfocaremos, \java{HashMap} y \java{TreeMap}. En capítulos
posteriores, examinaremos estas implementaciones y analizaremos su desempeño.

Además del \java{TermCounter}, que mapea términos de búsqueda a conteos,
definiremos una clase llamada \java{Index}, que mapea un término de
búsqueda con una colección de las páginas donde aparece. Y eso hace surgir
la siguiente pregunta, que es cómo representar una colección de páginas.
De nuevo, si pensamos en las operaciones que queremos realizar, eso guía
nuestra decisión.

\index{Set}
\index{intersección de conjuntos}

En este caso, necesitaremos combinar dos o más colecciones y encontrar las
páginas que aparecen en todas ellas. Podrías reconocer esta operación como
la \textbf{intersección de conjuntos}: la intersección de dos conjuntos es el
conjunto de elementos que aparecen en ambos.

Como podrías esperar, Java provee una interfaz \java{Set} (Conjunto, en inglés) que
define las operaciones que un conjunto debería realizar. No provee realmente una
intersección de conjuntos, pero provee métodos que hacen posible implementar la
intersección y otras operaciones de conjuntos eficientemente. Los métodos
principales de un \java{Set} son:

\begin{itemize}

\item
  \java{add(element)}: Este método añade un elemento al conjunto; si el
  elemento ya está en el conjunto, no tiene ningún efecto.

\item
  \java{contains(element)}: Este método comprueba si el elemento dado
  está en el conjunto.

\end{itemize}

Java provee varias implementaciones de \java{Set}, incluyendo
\java{HashSet} y \java{TreeSet}.

\index{add}
\index{contains}

Ahora que hemos diseñado nuestras estructuras de datos a nivel general,
las implementaremos desde lo más básico, comenzando con \java{TermCounter}.


\section{TermCounter}
\label{termcounter}

\index{TermCounter}

\java{TermCounter} es una clase que representa un mapeo de términos de búsqueda con
el número de veces que aparecen en una página. Aquí está la primera
parte de la definición de la clase:

\begin{verbatim}
public class TermCounter {

    private Map<String, Integer> map;
    private String label;

    public TermCounter(String label) {
        this.label = label;
        this.map = new HashMap<String, Integer>();
    }
}
\end{verbatim}

Las variables de instancia son \java{map}, que contiene el mapeo de
términos con conteos, y \java{label}, que identifica el documento del
que provienen los términos; la usaremos para guardar URLs.

\index{URL}
\index{Map}
\index{HashMap}

Para implementar el mapeo, elegí \java{HashMap}, que es el \java{Map} más
comúnmente usado. En unos cuantos capítulos, verás cómo funciona y por qué
es una elección común.

\java{TermCounter} provee \java{put} y \java{get}, que se
definen como sigue:

\begin{verbatim}
    public void put(String term, int count) {
        map.put(term, count);
    }

    public Integer get(String term) {
        Integer count = map.get(term);
        return count == null ? 0 : count;
    }
\end{verbatim}

\java{put} es solo un \textbf{método envoltorio (wrapper)}; cuando llamas
\java{put} en un \java{TermCounter}, éste llama a \java{put} en el
mapa embebido.

\index{put}
\index{get}
\index{método envoltorio}

Por otro lado, \java{get} de hecho hace un poco de trabajo. Cuando lo
llamas a \java{get} en un \java{TermCounter}, llama a \java{get} en el
mapa y comprueba el resultado. Si el término no aparece en el
mapa,\java{TermCount.get} devuelve 0. Al definir \java{get} de esta forma
es más fácil escribir \java{incrementTermCount}, que toma un término e
incrementa en uno el contador asociado con ese término.

\begin{verbatim}
    public void incrementTermCount(String term) {
        put(term, get(term) + 1);
    }
\end{verbatim}

Si el término no ha aparecido antes, \java{get} devuelve 0; le sumamos 1,
y luego usamos \java{put} para agregar un nuevo par clave-valor al mapa.
Si el término ya existe en el mapa, obtenemos el conteo anterior, le sumamos
1 y luego guardamos el nuevo conteo, que reemplaza al valor antiguo.

Además, \java{TermCounter} provee estos otros métodos para ayudar con
la indexación de páginas Web:

\begin{verbatim}
    public void processElements(Elements paragraphs) {
        for (Node node: paragraphs) {
            processTree(node);
        }
    }

    public void processTree(Node root) {
        for (Node node: new WikiNodeIterable(root)) {
            if (node instanceof TextNode) {
                processText(((TextNode) node).text());
            }
        }
    }

    public void processText(String text) {
        String[] array = text.replaceAll("\\pP", " ").
                              toLowerCase().
                              split("\\s+");

        for (int i=0; i<array.length; i++) {
            String term = array[i];
            incrementTermCount(term);
        }
    }
\end{verbatim}

\begin{itemize}

\item
  \java{processElements} toma un objeto \java{Elements}, que es una
  colección de objetos \java{Element} de jsoup. Itera por la
  colección y llama a \java{processTree} para cada uno.

\item
  \java{processTree} toma un \java{Node} de jsoup que representa la
  raíz de un árbol DOM. Itera por el árbol para encontrar los nodos
  que contienen texto; luego extrae el texto y lo pasa a
  \java{processText}.

\item
  \java{processText} toma una \java{String} que contiene palabras, espacios,
  signos de puntuación, etc. Remueve los signos de puntuación reemplazándolos
  con espacios, convierte las letras restantes a minúsculas, luego
  las separa en palabras. A continuación, itera por las palabras que encontró
  y llama a \java{incrementTermCount} con cada una.  Los métodos \java{replaceAll}
  y \java{split} toman {\bf expresiones regulares} como parámetros;
  puedes leer más sobre ellas en \url{http://thinkdast.com/regex}.

\end{itemize}

\index{Element}
\index{árbol DOM}
\index{expresión regular}

Finalmente, aquí está un ejemplo que demuestra cómo se usa \java{TermCounter}:

\begin{verbatim}
    String url = "http://en.wikipedia.org/wiki/Java_(programming_language)";
    WikiFetcher wf = new WikiFetcher();
    Elements paragraphs = wf.fetchWikipedia(url);

    TermCounter counter = new TermCounter(url);
    counter.processElements(paragraphs);
    counter.printCounts();
\end{verbatim}

Este ejemplo usa un \java{WikiFetcher} para descargar una página de
Wikipedia e interpretar el texto principal. Luego crea un
\java{TermCounter} y lo usa para contar las palabras en la página.

\index{WikiFetcher}

En la siguiente sección, tendrás una oportunidad de ejecutar este código y probar
tu comprensión al llenar un método faltante.


\section{Ejercicio 6}
\label{exercise6}

En el repositorio para este libro,
encontrarás los archivos de código fuente para este ejercicio:

\begin{itemize}

\item \java{TermCounter.java} contiene el código de la sección anterior.

\item \java{TermCounterTest.java} contiene código de prueba para
  \java{TermCounter.java}.

\item \java{Index.java} contiene la definición de la clase para la siguiente
  parte de este ejercicio.

\item \java{WikiFetcher.java} contiene la clase que usamos en el 
  ejercicio anterior para descargar e interpretar páginas Web.

\item \java{WikiNodeIterable.java} contiene la clase que usamos para recorrer
  los nodos en un árbol DOM.

\end{itemize}

También encontrarás el archivo de construcción Ant
\java{build.xml}.

\index{Ant}

Ejecuta \java{ant build} para compilar los archivos de código
  fuente. Luego ejecuta \java{ant TermCounter}; debería ejecutar el código
  de la sección anterior e imprimir una lista de términos y sus conteos. La
  salida debería verse algo así:

\begin{verbatim}
genericservlet, 2
configurations, 1
claimed, 1
servletresponse, 2
occur, 2
Total of all counts = -1
\end{verbatim}

Cuando lo ejecutes, el orden de los términos podría ser diferente.

\index{size}

Se supone que la última línea imprima el total de los conteos de términos, pero
devuelve \java{-1} porque el método \java{size} está incompleto.
Llena este método y ejecuta \java{ant TermCounter} de nuevo. El resultado
debería ser \java{4798}.

Ejecuta \java{ant TermCounterTest} para confirmar que esta parte del
ejercicio está completa y correcta.

\index{Index}

Para la segunda parte del ejercicio, presentaré una implementación de un
objeto \java{Index} y llenarás un método faltante. Aquí está el principio
de la definición de la clase:

\begin{verbatim}
public class Index {

    private Map<String, Set<TermCounter>> index = 
        new HashMap<String, Set<TermCounter>>();

    public void add(String term, TermCounter tc) {
        Set<TermCounter> set = get(term);

        // si vemos un término por primera vez, creamos un nuevo Set
        if (set == null) {
            set = new HashSet<TermCounter>();
            index.put(term, set);
        }
        // de lo contrario modificamos un Set existente
        set.add(tc);
    }

    public Set<TermCounter> get(String term) {
        return index.get(term);
    }
\end{verbatim}

La variable de instancia, \java{index}, es un mapa de cada término de búsqueda con
un conjunto de objetos \java{TermCounter}. Cada \java{TermCounter}
representa una página donde el término de búsqueda aparece.

El método \java{add} agrega un nuevo \java{TermCounter} al conjunto (set)
asociado con un término. Cuando indexamos un término que no había aparecido
antes, tenemos que crear un nuevo conjunto. De lo contrario, podemos simplemente
agregar un nuevo elemento a un set existente. En ese caso, \java{set.add} modifica
un set que vive dentro de un \java{index}, pero no modifica el \java{index}
en sí mismo. La única vez que modificamos \java{index} es cuando agregamos un
nuevo término.

\index{add}
\index{get}
Finalmente, el método \java{get} toma un término de búsqueda y devuelve el set
correspondiente de objetos \java{TermCounter}.

Esta estructura de datos es moderadamente más complicada. Para repasar,
un \java{Index} contiene un \java{Map} de cada término de búsqueda con un
\java{Set} de objetos \java{TermCounter}, y cada \java{TermCounter}
es un mapa de términos de búsqueda a conteos.

\begin{figure}
\centering
\includegraphics[width=4in]{figs/index.pdf}
\caption{Diagrama de objeto de un \java{Index}.}
\label{indexfig}
\end{figure}

La figura~\ref{indexfig} es un diagrama de objeto que muestra estos
objetos.  El objeto \java{Index} tiene una variable de instancia llamada
\java{index} que se refiere a un \java{Map}.  Es este ejemplo el
\java{Map} contiene sólo una cadena, \java{"Java"}, que se mapea
a un \java{Set} que contiene dos objetos \java{TermCounter},
uno para cada página donde la palabra ``Java'' aparece.

\index{diagrama de objeto}
\index{URL}

Cada \java{TermCounter} contiene \java{label}, que es la URL
de la página y \java{map}, que es un \java{Map} que
contiene las palabras en la página y el número de veces
que cada palabra aparece.

El método \java{printIndex} muestra cómo
desempaquetar esta estructura de datos:

\begin{verbatim}
    public void printIndex() {
        // itera por los términos de búsqueda
        for (String term: keySet()) {
            System.out.println(term);

            // para cada término, imprime las páginas en
            // las que aparece y sus frecuencias
            Set<TermCounter> tcs = get(term);
            for (TermCounter tc: tcs) {
                Integer count = tc.get(term);
                System.out.println("    " + tc.getLabel() + " " + count);
            }
        }
    }
\end{verbatim}

El bucle externo itera por los términos de búsqueda. El bucle interno itera por
los objetos \java{TermCounter}.

\index{Ant}

Ejecuta \java{ant build} para asegurarte que tu código fuente está compilado y
entonces ejecuta \java{ant Index}. Éste descarga dos páginas de Wikipedia, las
index e imprime los resultados; pero cuando lo ejecutes no verás ninguna
salida porque hemos dejado vacío uno de los métodos.

\index{indexPage}

Tu trabajo es llenar \java{indexPage}, que toma una URL (como una
\java{String}) y un objeto \java{Elements}, y actualiza el índice. Los
comentarios siguientes dicen a grandes rasgos lo que debería hacer:

\begin{verbatim}
public void indexPage(String url, Elements paragraphs) {
    // crea un TermCounter y cuenta los términos en los párrafos

    // para cada término en el TermCounter, agrega el TermCounter al index
}
\end{verbatim}

Cuando funcione, ejecuta \java{ant Index} de nuevo, y deberías ver
  una salida como esta:

\begin{verbatim}
...
configurations
    http://en.wikipedia.org/wiki/Programming_language 1
    http://en.wikipedia.org/wiki/Java_(programming_language) 1
claimed
    http://en.wikipedia.org/wiki/Java_(programming_language) 1
servletresponse
    http://en.wikipedia.org/wiki/Java_(programming_language) 2
occur
    http://en.wikipedia.org/wiki/Java_(programming_language) 2
\end{verbatim}

El orden de los términos de búsqueda podría ser diferente cuando lo ejecutes.

También, ejecuta \java{ant TestIndex} para confirmar que esta parte del ejercicio
está completa.


\chapter{La interfaz Map}

En los siguientes ejercicios, presento varias implementaciones de la
interfaz \java{Map}. Una de ellas está basada en una \textbf{tabla hash (hash table)},
que posiblemente es la estructura de datos más mágica alguna vez
inventada. Otra, que es similar a \java{TreeMap}, no es tan mágica,
pero tiene la capacidad adicional de permitir iterar por los
elementos en orden.

\index{mapa}
\index{tabla hash}

Tendrás una oportunidad de implementar estas estructuras de datos, y entonces
analizaremos su desempeño.

Pero antes de que podamos explicar las tablas hash, empezaremos con una
implementación simple de un \java{Map} usando una \java{List} de pares
clave-valor.

\section{Implementación de \java{MyLinearMap}}
\label{implementing-mylinearmap}

\index{MyLinearMap}

Como es usual, proveo un código para empezar y llenarás los métodos
faltantes. Aquí está el principio de la definición de la clase
\java{MyLinearMap}:

\begin{verbatim}
public class MyLinearMap<K, V> implements Map<K, V> {

    private List<Entry> entries = new ArrayList<Entry>();
\end{verbatim}

Esta clase usa dos parámetros de tipo, \java{K}, que es el tipo de
las claves, y \java{V}, que es el tipo de los valores.
\java{MyLinearMap} implementa \java{Map}, lo que significa que tiene que
proveer los métodos de la interfaz \java{Map}.

\index{parámetro de tipo}
\index{ArrayList}

Un objeto \java{MyLinearMap} tiene una única variable de instancia,
\java{entries}, que es una \java{ArrayList} de objetos
\java{Entry}. Cada \java{Entry} contiene un par clave-valor. Aquí
está la definición:

\begin{verbatim}
    public class Entry implements Map.Entry<K, V> {
        private K key;
        private V value;
        
        public Entry(K key, V value) {
            this.key = key;
            this.value = value;
        }
        
        @Override
        public K getKey() {
            return key;
        }
        @Override
        public V getValue() {
            return value;
        }
    }
\end{verbatim}

No hay mucho que decir; una \java{Entry} es solo un contenedor para una clave (key)
y un valor (value). Esta definición esta anidada dentro de \java{MyLinearList}, así
que usa los mismos parámetros de tipo, \java{K} y \java{V}.

\index{Entry}

Eso es todo lo que necesitas para hacer el ejercicio, así que comencemos.


\section{Ejercicio 7}
\label{exercise7}

En el repositorio para este libro, encontrarás
los archivos de código fuente para este ejercicio:

\begin{itemize}

\item \java{MyLinearMap.java} contiene código inicial para la primera parte
  del ejercicio.

\item \java{MyLinearMapTest.java} contiene los tests unitarios para
  \java{MyLinearMap}.

\end{itemize}

También encontrarás el archivo de construcción Ant
\java{build.xml}.

\index{Ant}

Ejecuta \java{ant build} para compilar los archivos fuente. Luego ejecuta \java{ant
  MyLinearMapTest}; varios tests fallarán, ¡porque aún tienes trabajo por hacer!

\index{método auxiliar}

Primero, llena el cuerpo de \java{findEntry}. Este es un método auxiliar
que no es parte de la interfaz \java{Map}, pero una vez consigas que
funcione, puedes usarlo para varios métodos. Dada una clave objetivo,
debería buscar a lo largo de las entradas (entries) y devolver la entrada
que contenga el objetivo (como una clave, no un valor) o \java{null} si no
está ahí. Nota que proveo un método \java{equals} que compara
dos claves y maneja los \java{null} correctamente.

\index{findEntry}

Puedes ejecutar \java{ant MyLinearMapTest} de nuevo, pero incluso si tu
\java{findEntry} es correo, los tests no pasarán porque \java{put}
no está completo.

\index{put}

Llena \java{put}. Deberías leer la documentación de
\java{Map.put} en \url{http://thinkdast.com/listput} para que sepas lo que
se supone que haga. Podrías querer iniciar con una versión de
\java{put} que siempre agregue una nueva entrada y no modifique una entrada
existente; de esa forma puedes probar el caso más simple primero. O si
te sientes con más confianza, puedes escribir todo el método de una vez.

\index{containsKey}
\index{get}
\index{remove}

Una vez logres que \java{put} funcione, el test para \java{containsKey}
debería pasar.

Lee la documentación de \java{Map.get} en
  \url{http://thinkdast.com/listget}
  y luego llena el método. Ejecuta los tests de nuevo.

Finalmente, lee la documentación de \java{Map.remove} en
  \url{http://thinkdast.com/maprem}
  y llena el método.

Llegados a este punto, todos los tests deberían pasar. ¡Felicitaciones!


\section{Análisis de \java{MyLinearMap}}
\label{analyzing-mylinearmap}

\index{equals}

En esta sección presento una solución al ejercicio anterior y
analizo el desempeño de los métodos principales. Aquí están
\java{findEntry} y \java{equals}:

\begin{verbatim}
private Entry findEntry(Object target) {
    for (Entry entry: entries) {
        if (equals(target, entry.getKey())) {
            return entry;
        }
    }
    return null;
}

private boolean equals(Object target, Object obj) {
    if (target == null) {
        return obj == null;
    }
    return target.equals(obj);
}
\end{verbatim}

El tiempo de ejecución de \java{equals} podría depender del tamaño del
\java{target} (objetivo) y las claves, pero generalmente no depende del
número de entradas, $n$. Así que \java{equals} es de tiempo constante.

\index{tiempo constante}
\index{análisis de algoritmos}

En \java{findEntry}, podríamos tener suerte y encontrar la clave que estamos
buscando al principio, pero no podemos contar con ello. En general, el número
de entradas que tenemos que buscar es proporcional a $n$, así que
\java{findEntry} es lineal.

\index{findEntry}
\index{tiempo lineal}

La mayoría de los métodos principales de \java{MyLinearMap} usan \java{findEntry},
incluyendo \java{put}, \java{get}, y \java{remove}. Así es como se ven:

\begin{verbatim}
public V put(K key, V value) {
    Entry entry = findEntry(key);
    if (entry == null) {
        entries.add(new Entry(key, value));
        return null;
    } else {
        V oldValue = entry.getValue();
        entry.setValue(value);
        return oldValue;
    }
}
\end{verbatim}

\begin{verbatim}
public V get(Object key) {
    Entry entry = findEntry(key);
    if (entry == null) {
        return null;
    }
    return entry.getValue();
}
\end{verbatim}
    
\begin{verbatim}
public V remove(Object key) {
    Entry entry = findEntry(key);
    if (entry == null) {
        return null;
    } else {
        V value = entry.getValue();
        entries.remove(entry);
        return value;
    }
}
\end{verbatim}

Después que \java{put} llama a \java{findEntry}, todo lo demás es de tiempo
constante. Recuerda que \java{entries} es una \java{ArrayList}, así que
agregar un elemento \emph{al final} es de tiempo constante, en promedio. Si la clave ya
está en el mapa, no tenemos que agregar una entrada, pero tenemos que llamar a
\java{entry.getValue} y \java{entry.setValue}, y ambos son de
tiempo constante. Al combinar todo, \java{put} es lineal.

\index{put}
\index{get}
\index{tiempo constante}

Siguiendo el mismo razonamiento, \java{get} también es lineal.

\java{remove} es ligeramente más complicado porque
\java{entries.remove} podría tener que remover un elemento del
principio o de la mita de la \java{ArrayList}, y eso toma tiempo
lineal. Pero está bien: dos operaciones lineales siguen siendo lineales.

\index{tiempo lineal}

En resumen, los métodos principales son todos lineales, y es por eso que
llamamos a esta implementación \java{MyLinearMap} (¡ta-da!).

Si sabemos que el número de entradas será pequeño, esta implementación
podría ser lo suficientemente buena, pero podemos mejorarla. De hecho,
hay una implementación de \java{Map} donde todos los métodos principales
son de tiempo constante. Cuando escuchas eso por primera vez, podría parecer
que no es posible. Lo que estamos diciendo, en efecto, es que puedes encontrar
una aguja en un pajar en tiempo constante, sin importar el tamaño del pajar.
Es magia.

\index{pajar}

Explicaré cómo funciona en dos pasos:

\begin{enumerate}

\item
  En lugar de guardar las entradas en una gran \java{List}, las dividiremos
  en muchas listas pequeñas. Para cada clave, usaremos un \textbf{código
  hash} (se explica en la siguiente sección) para determinar qué lista usar.

\item
  Usar muchas listas pequeñas es más rápido que usar solo una, pero como
  explicaré, no cambia el orden de crecimiento, las operaciones principales
  aún son lineales. Pero hay un truco adicional: si incrementamos el número
  de listas para limitar el número de entradas por lista, el resultado es
  un mapa de tiempo constante. Verás los detalles en el siguiente ejercicio,
  pero primero, ¡veamos qué es hashing!

\end{enumerate}


\index{código hash}

En el siguiente capítulo, presentaré una solución, analizaré el desempeño
de los métodos principales de \java{Map}, e introduciré una implementación
más eficiente.


\chapter{Hashing}
\label{cs-maps-hashing-readme}

En este capítulo, defino
\java{MyBetterMap}, una mejor implementación de la interfaz \java{Map}
que \java{MyLinearMap}, e introduzco el concepto de
\textbf{hashing}, que hace a \java{MyBetterMap} más eficiente.


\section{Hashing}
\label{hashing}

\index{hashing}
\index{MyBetterMap}

Para mejorar el desempeño de \java{MyLinearMap}, escribiremos una nueva
clase, llamada \java{MyBetterMap}, que contiene una colección de objetos
\java{MyLinearMap}. Esta clase divide las claves entre los mapas
embebidos, así que el número de entradas en cada mapa es más pequeño,
lo que hace más rápido a \java{findEntry} y los métodos que dependen de él.

Aquí está el principio de la definición de la clase:

\begin{verbatim}
public class MyBetterMap<K, V> implements Map<K, V> {
    
    protected List<MyLinearMap<K, V>> maps;
    
    public MyBetterMap(int k) {
        makeMaps(k);
    }

    protected void makeMaps(int k) {
        maps = new ArrayList<MyLinearMap<K, V>>(k);
        for (int i=0; i<k; i++) {
            maps.add(new MyLinearMap<K, V>());
        }
    }
}
\end{verbatim}

La variable de instancia, \java{maps}, es una colección de
objetos \java{MyLinearMap}. El constructor toma un parámetro,
\java{k}, que determina cuántos mapas usar, al menos inicialmente.
Luego \java{makeMaps} crea los mapas embebidos y los guarda en una
\java{ArrayList}.

\index{ArrayList}

Ahora, la clave para hacer que esto funcione es que necesitamos alguna forma
de ver una clave y decidir en cuál de los mapas embebidos debería ir. Cuando
ponemos (\java{put}) una nueva clave, elegimos una de los mapas; cuando
obtenemos (\java{get}) la misma clave, tenemos que recordar dónde la pusimos.

\index{get}
\index{Map}

Una posibilidad es elegir uno de los submapas al azar y llevar un
el control de en dónde pusimos cada clave. ¿Pero cómo llevaríamos el
control? Tal vez podríamos usar un \java{Map} para buscar la clave y encontrar
el sub-mapa correcto, pero todo el punto del ejercicio es escribir una
implementación eficiente de un \java{Map}. No podemos asumir que ya
tenemos una.

Una mejor aproximación es usar una \textbf{función hash}, que toma un
\java{Object}, cualquier \java{Object}, y devuelve un entero llamado
\textbf{código hash}.  Es importante que si esta función ve el mismo \java{Object}
más de una vez, siempre devuelva el mismo código hash. De esa manera, si
usamos el código hash para guardar una clave, obtendremos el mismo código
hash cuando la busquemos.

\index{función hash}
\index{código hash}

En java, cada \java{Object} provee un método llamado
\java{hashCode} que calcula una función hash. La implementación del
método es diferente para diferentes objetos; veremos un ejemplo
pronto.

\index{método auxiliar}

Aquí está un método auxiliar que elige el sub-mapa correcto para
una clave dada:

\begin{verbatim}
protected MyLinearMap<K, V> chooseMap(Object key) {
    int index = 0;
    if (key != null) { 
        index = Math.abs(key.hashCode()) % maps.size();
    }
    return maps.get(index);
}
\end{verbatim}

Si \java{key} es \java{null}, elegimos el sub-mapa con el índice 0,
de forma arbitraria. De lo contrario usamos \java{hashCode} para obtener un entero,
aplicamos \java{Math.abs} para asegurarnos que es no negativo,
y luego usamos el operador de residuo, \java{\%}, que nos garantiza que el
resultado está entre 0 y \java{maps.size()-1}. Así que \java{index} siempre
es un índice válido en \java{maps}. Luego \java{chooseMap} devuelve una
referencia al mapa que eligió.

\index{chooseMap}
\index{put}
\index{get}

Usamos \java{chooseMap} tanto en \java{put} como en \java{get}, para que
cuando busquemos una clave, obtengamos el mismo mapa que elegimos cuando
agregamos la clave. Por lo menos, deberíamos --- explicaré después por
qué esto podría no funcionar.

Aquí está mi implementación de \java{put} y \java{get}:

\begin{verbatim}
public V put(K key, V value) {
  MyLinearMap<K, V> map = chooseMap(key);
    return map.put(key, value);
}

public V get(Object key) {
    MyLinearMap<K, V> map = chooseMap(key);
    return map.get(key);
}
\end{verbatim}

Bastante simple, ¿verdad? En ambos métodos, usamos \java{chooseMap} para encontrar
el sub-mapa correcto y luego invocamos un método en el sub-mapa.
Así es como funciona, ahora pensemos en el desempeño.

\index{sub-mapa}

Si hay $n$ entradas distribuidas entre $k$ sub-mapas,
habrán $n/k$ entradas por mapa, en promedio. Cuando busquemos
una clave, tendremos que calcular su código hash, lo que toma algún
tiempo, entonces podemos buscar el sub-mapa correspondiente.

Porque las listas de entradas en
\java{MyBetterMap} son $k$ veces más cortas que la lista de entradas en
\java{MyLinearMap}, esperaríamos que la búsqueda sea $k$ veces
más rápida. Pero el tiempo de ejecución aún es proporcional a $n$, así
que \java{MyBetterMap} todavía es lineal. En el siguiente ejercicio, verás
cómo podemos arreglar eso.

\index{tiempo lineal}


\section{¿Cómo funciona el hashing?}
\label{how-does-hashing-work}

El requisito fundamental para una función hash es que el mismo objeto
debería producir el mismo código hash cada vez. Para objetos inmutables,
eso es relativamente sencillo. Para objetos con un estado mutable,
tenemos que pensar un poco más.

\index{SillyString}

Como un ejemplo de un objeto inmutable, definiré una clase llamada
\java{SillyString} que encapsula a una \java{String}:

\begin{verbatim}
public class SillyString {
    private final String innerString;

    public SillyString(String innerString) {
        this.innerString = innerString;
    }

    public String toString() {
        return innerString;
    }
\end{verbatim}

Esta clase no es muy útil, y es por eso que se llama \java{SillyString} (cadena tonta),
pero la usaré para mostrar cómo una clase puede definir su propia función hash:

\begin{verbatim}
    @Override
    public boolean equals(Object other) {
        return this.toString().equals(other.toString());
    }
    
    @Override
    public int hashCode() {
        int total = 0;
        for (int i=0; i<innerString.length(); i++) {
            total += innerString.charAt(i);
        }
        return total;
    }
\end{verbatim}

Nota que \java{SillyString} sobrescribe tanto \java{equals} como
\java{hashCode}. Esto es importante. Para funcionar correctamente,
\java{equals} tiene que ser consistente con \java{hashCode}, lo que significa
que si dos objetos son considerados iguales --- es decir, \java{equals}
devuelve \java{true} --- deberían tener el mismo código hash. Pero este
requerimiento sólo funciona en una vía; si dos objetos tienen el mismo
hash code, no necesariamente tienen que ser iguales.

\index{equals}
\index{toString}

\java{equals} funciona invocando \java{toString}, que devuelve
\java{innerString}. Así que dos objetos \java{SillyString} son iguales si
sus variables de instancia \java{innerString} son iguales.

\index{hashCode}

\java{hashCode} funciona iterando por los caracteres de la cadena (\java{String})
y sumándolos. Cuando sumas un carácter a un \java{int} Java convierte el
carácter a un entero usando su punto de código Unicode.  No necesitas
saber nada sobre Unicode para entender este ejemplo, pero si sientes
curiosidad, puedes leer más en
\url{http://thinkdast.com/codepoint}.

\index{Unicode}
\index{punto de código}

Esta función hash satisface el requisito: si dos objetos
\java{SillyString} contienen cadenas embebidas que son iguales,
obtendrán el mismo código hash.

Esto funciona correctamente, pero podría no tener un buen desempeño,
porque devuelve el mismo código hash para muchas cadenas diferentes. Si
dos cadenas contienen las mismas letras en cualquier orden, tendrán el
mismo código hash. E incluso si no contienen las mismas letras, podrían
producir el mismo total, como \java{"ac"} y \java{"bb"}.

Si muchos objetos tienen el mismo código hash, terminan en el mismo
sub-mapa. Si algunos sub-mapas tienen más entradas que otros, el incremento
en velocidad cuando tenemos $k$ mapas podría ser mucho menor que $k$. Así
que una de las metas de una función hash es ser uniforme; es decir, debería
ser igualmente probable que producirá un valor dentro del rango.  Puedes leer
más sobre el diseño de buenas funciones hash en
\url{http://thinkdast.com/hash}.

\index{sub-mapa}

\section{Hashing y mutación}
\label{hashing-and-mutation}

Las cadenas (\java{String}s) son inmutables y \java{SillyString} también es
inmutable porque \java{innerString} se declara como \java{final}. Una vez
crees una \java{SillyString}, no puedes hacer que \java{innerString} haga
referencia a una \java{String} diferente, y no puedes modificar la \java{String} a
la que se refiere. Por lo tanto, siempre tendrá el mismo código hash.

\index{mutable}
\index{immutable}
\index{SillyArray}

Pero veamos lo que ocurre con un objeto mutable. Aquí está una definición
para \java{SillyArray}, que es idéntica a \java{SillyString},
excepto que usa un arreglo de caracteres en lugar de una \java{String}:

\begin{verbatim}
public class SillyArray {
    private final char[] array;

    public SillyArray(char[] array) {
        this.array = array;
    }

    public String toString() {
        return Arrays.toString(array);
    }
    
    @Override
    public boolean equals(Object other) {
        return this.toString().equals(other.toString());
    }
    
    @Override
    public int hashCode() {
        int total = 0;
        for (int i=0; i<array.length; i++) {
            total += array[i];
        }
        System.out.println(total);
        return total;
    }
\end{verbatim}

\index{setChar}

\java{SillyArray} también provee \java{setChar}, lo que hace posible
modificar los caracteres en el arreglo:

\begin{verbatim}
public void setChar(int i, char c) {
    this.array[i] = c;
}
\end{verbatim}

Ahora supón que creamos un \java{SillyArray} y lo agregamos a un mapa:

\begin{verbatim}
SillyArray array1 = new SillyArray("Word1".toCharArray());
map.put(array1, 1);
\end{verbatim}

El código hash para este arreglo es 461. Ahora si modificamos el contenido
del arreglo y luego tratamos de ubicarlo, así:

\begin{verbatim}
array1.setChar(0, 'C');
Integer value = map.get(array1);
\end{verbatim}

El código hash tras la mutación es 441. Con un código hash diferente,
hay una probabilidad alta de que buscaremos en el sub-mapa equivocado. En
ese caso, no encontraremos la clave, incluso si está en el mapa. Y eso
es malo.

\index{código hash}

En general, es peligroso usar objetos mutables como claves en
estructuras de datos que usan hashing, lo que incluye a \java{MyBetterMap} 
y a \java{HashMap}. Si puedes garantizar que las claves no se modificarán
mientras están en el mapa, o que cualquier cambio no afectará el código
hash, podría ser aceptable. Pero probablemente es una buena idea evitarlo.


\section{Ejercicio 8}

\index{MyBetterMap}

En este ejercicio, finalizarás la implementación de
\java{MyBetterMap}.  En el repositorio para este libro,
encontrarás los archivos de código fuente para este ejercicio:

\begin{itemize}

\item
  \java{MyLinearMap.java} contiene nuestra solución al ejercicio anterior,
  sobre la que construiremos en este ejercicio.
\item
  \java{MyBetterMap.java} contiene el código del capítulo anterior con
  algunos métodos que tendrás que llenar.

\item
  \java{MyHashMap.java} contiene un boceto de una tabla hash que
  crece cuando se necesita, la cual completarás.

\item
  \java{MyLinearMapTest.java} contiene los tests unitarios para
  \java{MyLinearMap}.

\item
  \java{MyBetterMapTest.java} contiene los tests unitarios para
  \java{MyBetterMap}.

\item
  \java{MyHashMapTest.java} contiene los tests unitarios para
  \java{MyHashMap}.

\item
  \java{Profiler.java} contiene código para medir y graficar el
  tiempo de ejecución versus el tamaño del problema.

\item
  \java{ProfileMapPut.java} contiene código que perfile el método
  \java{Map.put}.
\end{itemize}

Como ya es costumbre, ejecutarás \java{ant build} para compilar los archivos
de código fuente. Luego ejecuta \java{ant MyBetterMapTest}. Varios tests deberían
fallar, ¡porque aún tienes trabajo por hacer!

\index{Ant}

Revisa la implementación de \java{put} y \java{get} del capítulo
anterior. Luego llena el cuerpo de \java{containsKey}. PISTA:
usa \java{chooseMap}. Ejecuta \java{ant MyBetterMapTest} de nuevo y
confirma que pasa \java{testContainsKey}.

\index{put}
\index{get}
\index{containsValue}

Llena el cuerpo de \java{containsValue}. PISTA: \emph{no} uses
\java{chooseMap}.  Ejecuta \java{ant MyBetterMapTest} de nuevo y confirma
que pasa \java{testContainsValue}. Nota que tenemos que trabajar más
para encontrar un valor que para encontrar una clave.

Como \java{put} y \java{get}, esta implementación de
\java{containsKey} es lineal, porque tiene que buscar uno de los
sub-mapas embebidos. En el siguiente capítulo, veremos cómo podemos
mejorar esta implementación aún más.

\index{tiempo lineal}


\chapter{HashMap}

En el capítulo anterior, escribimos una implementación de la
interfaz \java{Map} que usa hashing.  Esperamos que esta versión
sea más rápida, porque las listas en las busca son más cortas, pero
el orden de crecimiento todavía es lineal.

\index{HashMap}
\index{sub-mapa}

Si hay $n$ entradas y $k$ sub-mapas, el tamaño de los sub-mapas es
$n/k$ en promedio, que aún es proporcional a $n$.  Pero si
incrementamos $k$ junto con $n$, podemos limitar el tamaño de $n/k$.

Por ejemplo, supón que duplicamos $k$ cada vez que
$n$ excede $k$; en ese caso el número de entradas por
mapa sería menor a 1 en promedio, y prácticamente menor
que 10 todo el tiempo, siempre que la función hash distribuya
las claves razonablemente bien.

\index{tiempo constante}

Si el número de entradas por sub-mapa es constante, podemos buscar en un
único sub-mapa en tiempo constante. Y calcular la función hash generalmente
requiere tiempo constante (podría depender del tamaño de la clave, pero no
depende del número de claves). Eso hace a los métodos principales de
\java{Map},\java{put} y \java{get}, de tiempo constante.

En el siguiente ejercicio, verás los detalles.


\section{Ejercicio 9}
\label{implementing-myhashmap}

\index{MyHashMap}

En \java{MyHashMap.java}, proveo el código base de una tabla hash que
crece cuando se necesita. Aquí está el principio de la definición:

\begin{verbatim}
public class MyHashMap<K, V> extends MyBetterMap<K, V> implements Map<K, V> {

    // número promedio de entradas por sub-mapa antes de recodificar (rehash)
    private static final double FACTOR = 1.0;

    @Override
    public V put(K key, V value) {
        V oldValue = super.put(key, value);

        // comprueba si el número de elementos por sub-mapa excede el umbral
        if (size() > maps.size() * FACTOR) {
            rehash();
        }
        return oldValue;
    }
}
\end{verbatim}

\java{MyHashMap} extiende \java{MyBetterMap}, así que hereda los
métodos definidos ahí. El único método que sobrescribe es \java{put}
que llama a \java{put} en la superclase --- es decir,  llama a la
versión de \java{put} en \java{MyBetterMap} --- y luego comprueba
si tienen que recodificar (rehash). La llamada a \java{size} devuelve el
número total de entradas, $n$. La llamada a \java{maps.size} devuelve el
número de mapas embebidos, $k$.

\index{superclase}
\index{factor de carga}
\index{MyBetterMap}

La contante \java{FACTOR}, que se conoce como \textbf{factor de carga},
determina el número máximo de entradas por sub-mapa, en promedio. Si
\java{n > k * FACTOR}, significa que
\java{n/k > FACTOR}, lo que implica que el número de entradas
por sub-mapa excede el umbral, así que llamamos a \java{rehash}.

\index{Ant}

Ejecuta \java{ant build} para compilar los archivos de código fuente. Luego ejecuta \java{ant
  MyHashMapTest}.  Debería fallar porque la implementación de
\java{rehash} lanza una excepción. Tu trabajo es completarlo.

\index{rehash}

Llena el cuerpo de \java{rehash} para recopilar las entradas en la tabla,
redimensionar la tabla y luego poner las entradas de regreso. Proveo dos
métodos que podrían servirte: \java{MyBetterMap.makeMaps} y
\java{MyLinearMap.getEntries}. Tu solución debería duplicar el número
de mapas, $k$, cada vez que es llamada.


\section{Análisis de \java{MyHashMap}}
\label{analyzing-myhashmap}

\index{tiempo constante}

Si el número de entradas en el sub-mapa más grande es proporcional a
$n/k$, y $k$ crece en proporción a $n$, varios de los métodos
principales de \java{MyBetterMap} se vuelven de tiempo constante:

\begin{verbatim}
    public boolean containsKey(Object target) {
        MyLinearMap<K, V> map = chooseMap(target);
        return map.containsKey(target);
    }

    public V get(Object key) {
        MyLinearMap<K, V> map = chooseMap(key);
        return map.get(key);
    }

    public V remove(Object key) {
        MyLinearMap<K, V> map = chooseMap(key);
        return map.remove(key);
    }
\end{verbatim}

Cada método codifica (hashes) un clave (key), lo que es de tiempo
constante y luego invoca un método en un sub-mapa, que también es
de tiempo constante.

\index{put}

Hasta el momento, vamos bien. Pero el otro método principal, \java{put}, es un
poco más difícil de analizar. Cuando no tenemos que recodificar, es de tiempo
constante,  pero cuando tenemos que hacerlo, es lineal. En ese sentido, es similar
a \java{ArrayList.add}, que analizamos en la Sección~\ref{classifying-add}.

\index{tiempo lineal}

Por la misma razón, \java{MyHashMap.put} resulta ser de
tiempo constante si promediamos una serie de invocaciones
De nuevo, el argumento se base en el análisis amortizado
(ver la Sección~\ref{classifying-add}).

\index{análisis amortizado}

Supón que el número inicial de sub-mapas, $k$, es 2, y que el factor
de carga es 1. Ahora veamos cuánto trabajo requiere poner (\java{put}) una
serie de claves. Como ``unidad de trabajo'' básica, contaremos el número de
veces que tenemos que codificar una clave y agregarla a un sub-mapa.

\index{unidad de trabajo}

La primera vez que llamamos a \java{put} requiere 1 unidad de trabajo. La segunda
vez también toma 1 unidad. La tercera vez tenemos que recodificar, así que
toma 2 unidades recodificar las llaves existentes y 1 unidad recodificar la
nueva clave.

Ahora el tamaño de la tabla hash es 4, así que la siguiente vez que llamemos
a \java{put}, toma 1 unidad de trabajo. Pero la siguiente vez tenemos que
recodificar, lo que toma 4 unidades para recodificar las llaves existentes y 1
unidad para recodificar la nueva clave.

\index{hashing}

La figura ~\ref{fig-hashtable} muestra el patrón, con la carga normal de trabajo de
codificar una nueva clave en la parte inferior y el trabajo extra de recodificar se
muestra como una torre.

\begin{figure}
\centerline{\includegraphics[width=5.5in]{figs/tower.pdf}}
\caption{Representación del trabajo realizado para agregar elementos a una tabla hash.}
\label{fig-hashtable}
\end{figure}

Como la flecha sugiere, si derribamos las torres, cada una llenará el
espacio antes de la siguiente torre. El resultado es una altura uniforme
de 2 unidades, que muestra que el trabajo promedio por \java{put} es de alrededor
de 2 unidades. Y eso significa que \java{put} es de tiempo constante en promedio.

Este diagrama también muestra por qué es importante duplicar el número de
sub-mapas, $k$, cuando recodificamos. Si solamente sumamos a $k$
en lugar de multiplicar, las torres estarían demasiado cercanas entre sí
y comenzarían a apilarse. Y eso no sería de tiempo constante.

\index{tiempo constante}


\section{Limitaciones}
\label{the-tradeoffs}

Hemos mostrado que \java{containsKey}, \java{get}, y \java{remove}
son de tiempo constante y que \java{put} es de tiempo constante en
promedio. Deberíamos tomarnos un minuto para apreciar cuán notable
es eso. El rendimiento de estas operaciones es prácticamente el mismo
sin importar qué tan grande sea la tabla hash. Bueno, en cierto modo.

\index{containsKey}
\index{get}
\index{remove}
\index{put}

Recuerda que nuestro análisis se basa un un modelo simple de cálculo
donde cada ``unidad de trabajo'' toma la misma cantidad de tiempo. En
la vida real, las computadoras son más complicadas. En particular, 
usualmente son más rápidas cuando trabajan con estructuras de datos lo
suficientemente pequeñas para caber en la caché, un poco más lentas si
la estructura de datos no cabe en caché pero sí en la memoria; y \emph{mucho}
más lentas si la estructura no cabe en la memoria.

\index{cache}
\index{containsValue}

Otra limitación de esta implementación es que el hashing no nos ayuda
si nos dan un valor en lugar de una clave: \java{containsValue} es
lineal porque tiene que buscar todos los sub-mapas. Y no hay una forma
particularmente eficiente de buscar un valor y encontrar la clave (o
posiblemente, claves) correspondiente.

\index{tiempo lineal}

Y hay una limitación más: algunos de los métodos que eran de tiempo
constante en \java{MyLinearMap} se han vuelto lineales. Por ejemplo:

\begin{verbatim}
    public void clear() {
        for (int i=0; i<maps.size(); i++) {
            maps.get(i).clear();
        }
    }
\end{verbatim}

\java{clear} tiene que limpiar todos los sub-mapas, y el número de
sub-mapas es proporcional a $n$, así que es lineal. Afortunadamente,
esta operación no se usa muy a menudo, así que para la mayoría de
aplicaciones este sacrificio es aceptable.

\index{clear}


\section{Perfilado de \java{MyHashMap}}
\label{profiling-myhashmap}

Antes de continuar, deberíamos comprobar si \java{MyHashMap.put} realmente
es de tiempo constante.

\index{MyHashMap}
\index{perfilado}
\index{Ant}

Ejecuta \java{ant build} para compilar los archivos de código
fuente. Luego ejecuta \java{ant ProfileMapPut}. Este programa mide el
tiempo de ejecución de \java{HashMap.put} (proporcionado por Java) con un
rango de tamaños de problemas y grafica el tiempo de ejecución versus el
tamaño del problema en una escala log-log. Si esta operación es de
tiempo constante, el tiempo total para $n$ operaciones debería ser
lineal, así que el resultado debería ser una línea recta con pendiente
de 1. Cuando ejecuté este código, la pendiente estimada era cercana a 1,
lo que es consistente con nuestro análisis. Deberías obtener algo similar.

Modifica \java{ProfileMapPut.java} para perfilar tu implementación,
\java{MyHashMap}, en lugar del \java{HashMap} de Java. Ejecuta el
perfilador de nuevo y observa si la pendiente es cercana a 1. Podrías
tener que ajustar \java{startN} y \java{endMillis} para encontrar un rango
de tamaños del problema donde los tiempos de ejecución sean mayores a unos
pocos milisegundos, pero no más de unos cuantos miles.

Cuando ejecuté este código, me sorprendí: la pendiente era alrededor de 1.7,
lo que sugiere que esta implementación no es de tiempo constante después de
todo. Contiene un ``bug de rendimiento'. 

\index{bug de rendimiento}

Antes de leer la siguiente sección, deberías rastrear el error, arreglarlo
y confirmar que \java{put} es de tiempo constante, como se esperaba.


\section{Arreglando \java{MyHashMap}}
\label{fixing-myhashmap}

\index{size}

El problema con \java{MyHashMap} está en \java{size}, que se
heredó de \java{MyBetterMap}:

\begin{verbatim}
    public int size() {
        int total = 0;
        for (MyLinearMap<K, V> map: maps) {
            total += map.size();
        }
        return total;
    }
\end{verbatim}

Para calcular el tamaño total tiene que iterar por todos los sub-mapas. 
Dado que incrementamos el número de submapas, $k$, conforme el número
de entradas, $n$, se incrementa, $k$ es proporcional a $n$, así que
\java{size} es lineal.

\index{tiempo lineal}

Y eso hace que \java{put} también sea lineal, porque usa a \java{size}:

\begin{verbatim}
    public V put(K key, V value) {
        V oldValue = super.put(key, value);

        if (size() > maps.size() * FACTOR) {
            rehash();
        }
        return oldValue;
    }
\end{verbatim}

¡Todo lo que hicimos para hacer a \java{put} de tiempo constante es un desperdicio
si \java{size} es lineal!

\index{tiempo constante}
\index{tiempo lineal}

Afortunadamente, hay una solución simple, y la hemos visto antes: tenemos
que llevar la cuenta del número de entradas en una variable de instancia y
actualizarla cada vez que llamemos a un método que la cambie.

\index{MyFixedHashMap}

Encontrarás esta solución en el repositorio para este libro, en
\java{MyFixedHashMap.java}.  Aquí está el principio de la definición de la clase:

\begin{verbatim}
public class MyFixedHashMap<K, V> extends MyHashMap<K, V> implements Map<K, V> {

    private int size = 0;

    public void clear() {
        super.clear();
        size = 0;
    }
\end{verbatim}

En lugar de modificar \java{MyHashMap}, defino una nueva clase que
la extiende. Esta clase agrega una nueva variable de instancia, \java{size}, 
que se inicializa en cero.

Actualizar \java{clear} es directo; invocamos a \java{clear} en
la superclase (lo que limpia los sub-mapas), y luego actualizamos
\java{size}.

\index{superclass}

Actualizar \java{remove} y \java{put} es un poco más difícil
porque cuando invocamos el método en la superclase, no podemos decir
si el tamaño del sub-mapa cambió. Así es como superé esta limitante:

\begin{verbatim}
    public V remove(Object key) {
        MyLinearMap<K, V> map = chooseMap(key);
        size -= map.size();
        V oldValue = map.remove(key);
        size += map.size();
        return oldValue;
    }
\end{verbatim}

\java{remove} usa a \java{chooseMap} para encontrar el sub-mapa correcto, luego
sustrae el tamaño (size) del sub-mapa. Invoca a \java{remove} en el
sub-mapa, que puede o no cambiar el tamaño del sub-mapa,
dependiendo de si encuentra la clave. Pero de cualquier forma, agregamos
el nuevo tamaño del sub-mapa a \java{size}, así que el valor final de
\java{size} es correcto.

\index{remove}

La versión reescrita de \java{put} es similar:

\begin{verbatim}
    public V put(K key, V value) {
        MyLinearMap<K, V> map = chooseMap(key);
        size -= map.size();
        V oldValue = map.put(key, value);
        size += map.size();

        if (size() > maps.size() * FACTOR) {
            size = 0;
            rehash();
        }
        return oldValue;
    }
\end{verbatim}

Tenemos el mismo problema aquí: cuando invocamos a \java{put} en el
sub-mapa, no sabemos si se agregó una nueva entrada. Así que usamos la misma
solución, sustrayendo el tamaño (size) antiguo y luego sumando el nuevo.

\index{put}
\index{size}

Ahora la implementación del método \java{size} es simple:

\begin{verbatim}
    public int size() {
        return size;
    }
\end{verbatim}

Y esta es claramente de tiempo constante.

\index{tiempo constante}

Cuando perfilé esta solución, encontré que el tiempo total para poner
$n$ claves es proporcional a $n$, lo que significa que cada \java{put} es
de tiempo constante, como debe ser.

\index{perfilado}


\section{Diagramas de clases UML}
\label{uml-class-diagrams}

\index{UML}
\index{diagrama de clase}

Un desafío de trabajar con el código en este capítulo es que tenemos
varias clases que dependen una de la otra. Aquí están algunas de las
relaciones entre las clases:

\begin{itemize}

\item
  \java{MyLinearMap} contiene una \java{LinkedList} e implementa
  \java{Map}.
\item
  \java{MyBetterMap} contiene muchos objetos \java{MyLinearMap} e
  implementa \java{Map}.
\item
  \java{MyHashMap} extiende a \java{MyBetterMap}, así que también contiene
  objetos \java{MyLinearMap} e implementa \java{Map}.
\item
  \java{MyFixedHashMap} extiende a \java{MyHashMap} e
  implementa \java{Map}.
\end{itemize}

Para llevar el control de relaciones como estas, los ingenieros de software
a menudo usan {\bf diagramas de clases UML}. UML significa Unified Modeling
Language (Lenguaje de Modelado Unificado)
(véase \url{http://thinkdast.com/uml}).
Un ``diagrama de clase'' es uno de varios estándares gráficos definidos por UML.

En un diagrama de clases, cada clase se representa con una caja y
las relaciones entre clases se representan con flechas. La
figura~\ref{fig-uml} muestra un diagrama de clases UML para las clases
del ejercicio anterior, generado usando la herramienta en línea yUML en
\url{http://yuml.me/}.

\begin{figure}
\centering
\includegraphics[width=5in]{figs/yuml1.pdf}
\caption{Diagrama UML para las clases de este capítulo.}
\label{fig-uml}
% Edit: http://yuml.me/edit/2aa18a2d
\end{figure}

\index{herencia}
\index{relación ES-UN(A)}
\index{relación TIENE-UN(A)}

Las relaciones diferentes se representan con flechas diferentes:

\begin{itemize}

\item
  Las flechas con una punta sólida indican una relación TIENE-UN(A). Por ejemplo,
  cada instancia de \java{MyBetterMap} contiene múltiples instancias de
  \java{MyLinearMap}, así que se conectan con una flecha sólida.

\item
  Las flechas con una punta en blanco y una línea sólida indican relaciones
  ES-UN(A). Por ejemplo, \java{MyHashMap} extiende a
  \java{MyBetterMap}, así que se conectan con una flecha ES-UN(A).

\item
  Las flechas con una punta en blanco y una línea punteada indican que
  una clase implementa una interfaz; en este diagrama, cada clase implementa
  \java{Map}.

\end{itemize}

Los diagramas de clase UML proveen una forma concisa de representar un
montón de información sobre una colección de clases. Usualmente se usan
durante las fases de diseño para comunicar diseños alternativos, durante
las fases de implementación para mantener un mapa mental compartido del
proyecto y durante el despliegue para documentar el diseño.


\chapter{TreeMap}

\index{TreeMap}
\index{Map}

Este capítulo presenta el árbol binario de búsqueda, que es una implementación
eficiente de la interfaz \java{Map} que es particularmente útil si queremos
mantener los elementos ordenados.

\section{¿Qué tiene de malo el hashing?}

En este momento, ya deberías estar familiarizado con la interfaz \java{Map} y
la implementación \java{HashMap} provista por Java. Y al construir tu propio
\java{Map} usando una tabla hash, deberías entender cómo funciona \java{HashMap}
y por qué esperamos que sus métodos principales sean de tiempo lineal.

\index{tiempo constante}

Debido a su desempeño, \java{HashMap} es ampliamente usado, pero no es la
única implementación de \java{Map}. Hay una pocas razones por las que podrías
querer otra implementación:

\begin{enumerate}

\item
  El hashing puede ser lento, así que aunque las operaciones de \java{HashMap} sean
  de tiempo constante, la ``constante'' podría ser grande.

\item
  El hashing funciona bien si la función hash distribuye las llaves de forma
  equitativa entre los sub-mapas. Pero el diseño de buenas funciones hash no
  es fácil y si demasiadas claves terminan en el mismo sub-mapa, el desempeño
  de \java{HashMap} podría ser pobre.

\item
  Las llaves en una tabla hash no se guardan en ningún orden particular; de
  hecho, el orden podría cambiar cuando la tabla crezca y las llaves sean
  recodificadas (rehashed). Para algunas aplicaciones, es necesario, o por
  lo menos útil, mantener las clave en orden.

\end{enumerate}

Es difícil resolver todos estos problemas a la vez, pero
Java provee una implementación llamada \java{TreeMap} que se
casi lo consigue:

\begin{enumerate}

\item
  No usa una función hash, así que evita el costo del hashing
  y la dificultad de elegir una función hash.

\item
  Dentro del \java{TreeMap}, las claves se guardan en un
  \textbf{árbol binario de búsqueda}, lo que posibilita recorrer las
  claves, en orden, en tiempo lineal.

\item
  El tiempo de ejecución de los métodos principales es proporcional a $\log n$,
  que no tan bueno como tiempo constante, pero todavía es muy bueno.

\end{enumerate}

En la siguiente sección, explicaré cómo funcionan los árboles binarios de búsqueda
y usarás uno para implementar un \java{Map}. Durante el viaje, analizaremos el
desempeño de los métodos principales de un mapa cuando se implementan con un árbol.

\index{tiempo lineal}


\section{Árbol binario de búsqueda}
\label{binary-search-tree}

\index{árbol binario de búsqueda}
\index{ABB}
\index{propiedad ABB}
\index{node}

Un árbol binario de búsqueda (ABB) es un árbol donde cada nodo (node) contiene
una clave y cada \java{node} tiene la ``propiedad ABB'':

\begin{enumerate}

\item
  Si \java{node} tiene un hijo izquierdo, todas las claves en el subárbol izquierdo deben
  ser menores que la clave en \java{node}.

\item
  Si \java{node} tiene un hijo derecho, todas las claves en el subárbol derecho deben
  ser mayores que la clave en el \java{node}.

\end{enumerate}

\begin{figure}
\centering
\includegraphics[height=2.5in]{figs/Binary_search_tree_1229.png}
%\includegraphics[height=2.5in]{figs/Binary_search_tree.svg}
\caption{Ejemplo de un árbol binario de búsqueda.}
\label{fig-bst}
\end{figure}

La figura~\ref{fig-bst} muestra un árbol de enteros que tiene esta propiedad.
Esta figura es de la página de Wikipedia sobre árboles binarios de búsqueda en
\url{http://thinkdast.com/bst}, que podrías
encontrar útil mientras trabajas en este ejercicio.

La clave en la raíz es 8 y puedes confirmar que todas las claves a la izquierda
de la raíz son menores que 8 y todas las claves a la derecha son mayores.
También puedes verificar que los otros nodos tienen esta propiedad.

\index{clave}

Buscar una clave en un árbol binario de búsqueda es rápido porque no tenemos
que buscar en el árbol entero. Comenzando en la raíz, podemos usar el
siguiente algoritmo:

\begin{enumerate}

\item
  Compara la clave (key) que estás buscando, \java{target}, a la clave
  en el nodo actual. Si son iguales, has terminado.

\item
  Si \java{target} es menor que la clave actual, busca en el árbol izquierdo.
  Si no hay uno, \java{target} no está en el árbol.

\item
  Si \java{target} es mayor que la clave actual, busca en el árbol derecho.
  Si no hay uno, \java{target} no está en el árbol.

\end{enumerate}

En cada nivel del árbol, tienes que buscar sólo en un hijo. Por ejemplo,
si buscar \java{target = 4} en el diagrama anterior, comienzas en la
raíz, que contiene la clave \java{8}. Porque
\java{target} es menor que \java{8}, te vas a la izquierda. Porque
\java{target} es mayor que \java{3} te vas a la derecha. Porque
\java{target} es menor que \java{6}, te vas a la izquierda. Y entonces
encuentras la clave que estabas buscando.

En este ejemplo, toma cuatro comparaciones encontrar el objetivo (target),
aunque el árbol contiene nueve claves. En general, el número de
comparaciones es proporcional a la altura del árbol, no al número de
claves en el árbol.

\index{altura}

Entonces, ¿qué podemos decir sobre la relación entre la altura del
árbol, \java{h}, y el número de nodos, $n$? Comenzando con un número
bajo e incrementándolo gradualmente:

\begin{itemize}

\item
  Si \java{h=1}, el árbol sólo contiene un nodo, así que \java{n=1}.

\item
  Si \java{h=2}, podemos agregar dos nodos más, para un total de
  \java{n=3}.

\item
  Si \java{h=3}, podemos agregar hasta cuatro nodos más, para un total
  de \java{n=7}.

\item
  Si \java{h=4}, podemos agregar hasta ocho nodos más, para un total
  de \java{n=15}.

\end{itemize}

Por ahora puedes ver el patrón. Si numeramos los niveles del árbol desde
\java{1} hasta \java{h}, el nivel con índice \java{i} puede tener hasta
$2^{i-1}$ nodos. Y el número total de nodos en \java{h} niveles es $2^h-1$.
Si tenemos

\[ n = 2^h - 1 \]

podemos calcular el logaritmo base 2 de ambos lados:

\[ log_2 n \approx h \]

lo que significa que la altura del árbol es proporcional a
$\log n$, si el árbol está lleno; es decir, si cada nivel contiene el
máximo número de nodos.

Así que esperamos poder buscar una clave en un árbol binario de búsqueda
en un tiempo proporcional a $\log n$. Esto es cierto si el árbol está lleno e
incluso si el árbol está solo parcialmente lleno. Pero no siempre es cierto,
como veremos.

\index{tiempo logarítmico}
\index{logaritmo}
\index{orden de crecimiento}

Un algoritmo que toma tiempo proporcional a $\log n$ es llamado
``logarítmico'' o de ``tiempo logarítmico'', y pertenece a la orden de crecimiento
$O(\log n)$.


\section{Ejercicio 10}
\label{exercise10}

Para este ejercicio escribirás una implementación de la
interfaz \java{Map} usando un árbol binario de búsqueda.

\index{Map}

Aquí está el principio de una implementación, llamada \java{MyTreeMap}:

\begin{verbatim}
public class MyTreeMap<K, V> implements Map<K, V> {

    private int size = 0;
    private Node root = null;
\end{verbatim}

Las variables de instancia son \java{size}, que lleva el control del
número de claves, y \java{root}, que es una referencia al nodo raíz
del árbol. Cuando el árbol está vacío, \java{root} es \java{null} y
\java{size} es 0.

Aquí está la definición de \java{Node}, que se define dentro de
\java{MyTreeMap}:

\begin{verbatim}
    protected class Node {
        public K key;
        public V value;
        public Node left = null;
        public Node right = null;

        public Node(K key, V value) {
            this.key = key;
            this.value = value;
        }
    }
\end{verbatim}

\index{Node}
\index{par clave-valor}

Cada nodo contiene un par clave-valor (key-value) y referencias a dos
nodos hijos \java{left} (izquierdo) y \java{right} (derecho). Cualquiera
o ambos de los nodos hijos pueden ser \java{null}.

Algunos de los métodos de \java{Map} son fáciles de implementar, como
\java{size} y \java{clear}:

\begin{verbatim}
    public int size() {
        return size;
    }

    public void clear() {
        size = 0;
        root = null;
    }
\end{verbatim}

\java{size} es claramente de tiempo constante.

\index{size}
\index{tiempo constante}

\java{clear} pareciera ser de tiempo constante, pero considera esto: cuando
\java{root} se modifica a \java{null}, el recolector de basura reclama la memoria
de los nodos en el árbol, lo que toma tiempo lineal. ¿Deberíamos contar el trabajo
que realiza el recolector de basura? Pienso que sí.

\index{clear}
\index{tiempo lineal}

En la siguiente sección, llenarás algunos de los otros métodos, incluyendo
los más importantes, \java{get} y \java{put}.

\section{Implementación de un TreeMap}

\index{MyTreeMap}

En el repositorio para este libro, encontrarás estos archivos de código fuente:

\begin{itemize}

\item
  \java{MyTreeMap.java} contiene el código de la sección anterior con un boceto
  para los métodos faltantes.

\item
  \java{MyTreeMapTest.java} contiene los tests unitarios para
  \java{MyTreeMap}.

\end{itemize}

Ejecuta \java{ant build} para compilar los archivos de código fuente. Luego ejecuta
\java{ant MyTreeMapTest}.  Varios tests deberían fallar, ¡porque tienes trabajo por
hacer!

\index{Ant}

He provisto bocetos para \java{get} y \java{containsKey}.  Ambos usan
\java{findNode}, que es un método privado que yo definí; no es parte
de la interfaz \java{Map}. Así es como comienza:

\begin{verbatim}
    private Node findNode(Object target) {
        if (target == null) {
            throw new IllegalArgumentException();
        }

        @SuppressWarnings("unchecked")
        Comparable<? super K> k = (Comparable<? super K>) target;

        // TODO: FILL THIS IN!
        return null;
    }
\end{verbatim}

\index{get}
\index{containsKey}
\index{findNode}

El parámetro \java{target} es la clave que estamos buscando. Si
\java{target} es \java{null}, \java{findNode} lanza una excepción.
Algunas implementaciones de \java{Map} pueden manejar \java{null} como una clave,
pero en un árbol binario de búsqueda, necesitamos ser capaces de comparar
claves, así que lidiar con \java{null} es problemático. Para mantener las cosas
simples, esta implementación no permite \java{null} como una clave.

Las siguientes líneas muestran cómo podemos comparar \java{target} a una clave
en el árbol. De la firma de \java{get} y \java{containsKey}, el compilador
considera a \java{target} como un \java{Object}. Pero necesitamos poder
comparar claves, así que convertimos \java{target} a un
\java{Comparable<? super K>}, lo que significa que
es comparable a una instancia de tipo \java{K}, o cualquier superclase de
\java{K}.  Si no estás familiarizado con este uso del ``tipo comodín'', 
puedes leer más al respecto en
\url{http://thinkdast.com/gentut}.

\index{tipo comodín}
\index{superclase}

Afortunadamente, lidiar con el sistema de tipos de Java no es el punto de
este ejercicio. Tu trabajo es llenar el resto de \java{findNode}. Si
encuentra un nodo que contiene \java{target} como una clave, debería devolver
el nodo. De lo contrario, debería devolver \java{null}. Cuando logres que esto
funcione, debería pasar los tests para \java{get} y \java{containsKey}.

Nota que tu solución debería buscar únicamente una ruta a lo largo del árbol,
así que debería tomar tiempo proporcional a la altura del árbol.  ¡No deberías
buscar en todo el árbol!

\index{altura}
\index{método auxiliar}

Tu siguiente tarea es llenar \java{containsValue}. Para comenzar,
he provisto un método auxiliar, \java{equals}, que compara
\java{target} y una clave dada. Nota que los valores en el árbol (a
diferencia de las claves) no son necesariamente comparables, así que
no podemos usar \java{compareTo}; tenemos que invocar \java{equals}
en el \java{target}.

\index{containsValue}

A diferencia de tu solución anterior para \java{findNode}, tu solución para
\java{containsValue} \emph{tiene} que buscar en el árbol completo, así que
su tiempo de ejecución es proporcional al número de claves, $n$, no a la
altura del árbol, \java{h}.

El siguiente método que deberías llenar es \java{put}. He provisto
  un código inicial que maneja los casos más simples:

\begin{verbatim}
    public V put(K key, V value) {
        if (key == null) {
            throw new IllegalArgumentException();
        }
        if (root == null) {
            root = new Node(key, value);
            size++;
            return null;
        }
        return putHelper(root, key, value);
    }

    private V putHelper(Node node, K key, V value) {
        // TODO: Fill this in.
    }
\end{verbatim}

Si tratas de poner \java{null} como una clave, \java{put} lanza una
excepción.

Si el árbol está vacío, \java{put} crea un nuevo nodo e inicializa
la variable de instancia \java{root}.

\index{put}
\index{método auxiliar}

De otra forma, llama a \java{putHelper}, que es un método privado que yo
definí; no es parte de la interfaz \java{Map}.

Llena \java{putHelper} para que busque en el árbol y:

\begin{enumerate}

\item
  Si \java{key} ya está en el árbol, reemplace el valor antiguo con el
  nuevo, y devuelva el valor antiguo.

\item
  Si \java{key} no está en el árbol, cree un nuevo nodo, encuentre el
  lugar correcto para agregarlo y devuelva \java{null}.

\end{enumerate}

Tu implementación de  \java{put} debería tomar tiempo proporcional a la
altura del árbol, $h$, no al número de elementos, $n$. Idealmente
debería buscar en el árbol solo una vez, pero si encuentras más fácil
buscar dos veces, puedes hacerlo; será más lento, pero no cambia el
orden de crecimiento.

\index{keySet}

Finalmente, deberías llenar el cuerpo de \java{keySet}.  De acuerdo con
la documentación en \url{http://thinkdast.com/mapkeyset}, este método
debería devolver un \java{Set} que itere por las claves en orden; es decir,
en orden ascendente de acuerdo con el método \java{compareTo}.  La
implementación \java{HashSet} de un \java{Set}, que usamos en la
Sección~\ref{exercise6}, no mantiene el orden de las claves, pero
la implementación \java{LinkedHashSet} sí lo hace.  Puedes leer sobre ella
en \url{http://thinkdast.com/linkedhashset}.

He provisto un boceto de \java{keySet} que crea y devuelve un
\java{LinkedHashSet}:

\begin{verbatim}
    public Set<K> keySet() {
        Set<K> set = new LinkedHashSet<K>();
        return set;
    }
\end{verbatim}

\index{método auxiliar}
\index{recursión}

Deberías finalizar este método para que agregue las claves del árbol al
\java{set} en orden ascendente. PISTA: podrías querer escribir un método
auxiliar; podrías querer hacerlo recursivo; y podrías querer leer sobre
el recorrido en orden de un árbol en
\url{http://thinkdast.com/inorder}.

\index{en orden} 
\index{recorrido de un árbol}

% TODO: more help with recursion?

Cuando hayas finalizado, deberían pasar todos los tests. En el siguiente
capítulo, presentaré mis soluciones y comprobaré el desempeño de los
métodos principales.


\chapter{Árbol binario de búsqueda}

Este capítulo presenta las soluciones al ejercicio anterior, luego prueba
el desempeño del mapa basado en un árbol. Presento un problema con la
implementación y explico cómo el \java{TreeMap} de Java lo resuelve.


\section{Un \java{MyTreeMap} simple}
\label{our-version-of-mytreemap}

En el ejercicio anterior te dí un boceto de \java{MyTreeMap} y
te pedí que llenaras los métodos faltantes. Ahora presentaré una
solución, comenzando con \java{findNode}:

\index{MyTreeMap}
\index{findNode}

\begin{verbatim}
private Node findNode(Object target) {
    // algunas implementaciones pueden tratar a null como clave, no esta
    if (target == null) {
            throw new IllegalArgumentException();
    }

    // algo para hacer feliz al compilador
    @SuppressWarnings("unchecked")
    Comparable<? super K> k = (Comparable<? super K>) target;

    // la búsqueda como tal
    Node node = root;
    while (node != null) {
        int cmp = k.compareTo(node.key);
        if (cmp < 0)
            node = node.left;
        else if (cmp > 0)
            node = node.right;
        else
            return node;
    }
    return null;
}
\end{verbatim}

\java{findNode} es un método privado usado por \java{containsKey} y
\java{get}; no es parte de la interfaz \java{Map} El parámetro
\java{target} es la clave que buscamos. Expliqué la primera parte
de este método en el ejercicio previo:

\begin{itemize}

\item
  En esta implementación, \java{null} no es un valor legal para una clave.

\item
  Antes de que podamos invocar a \java{compareTo} en \java{target}, tenemos
  que convertirlo a algún tipo de \java{Comparable}. El ``tipo comodín''
  usado aquí es tan permisivo como resulta posible; es decir, funciona con
  cualquier tipo que implemente \java{Comparable} y cuyo método \java{compareTo}
  acepte \java{K} o cualquier supertipo de \java{K}.

\end{itemize}

\index{tipo comodín}

Después de todo eso, la búsqueda como tal es relativamente simple. Inicializamos una
variable de repetición \java{node} que se refiera al nodo raíz. En cada repetición
del bucle, comparamos el objetivo (target) con \java{node.key}. Si el objetivo
es menor que la clave actual, nos movemos al hijo izquierdo. Si es mayor, nos
movemos el hijo derecho. Y si son iguales, devolvemos el nodo actual.

Si llegamos a la parte inferior del árbol sin encontrar el objetivo,
concluimos que no está en el árbol y devolvemos \java{null}.


\section{Búsqueda de valores}
\label{searching-for-values}

Como expliqué en el ejercicio previo, el tiempo de ejecución de
\java{findNode} es proporcional a la altura del árbol, no al
número de nodos, porque no tenemos que buscar en el árbol completo.
Pero para \java{containsValue}, tenemos que buscar los valores, no las claves;
la propiedad ABB no aplica a los valores, así que tenemos que buscar en el
árbol completo.

\index{recursión}

Mi solución es recursiva:

\begin{verbatim}
public boolean containsValue(Object target) {
    return containsValueHelper(root, target);
}

private boolean containsValueHelper(Node node, Object target) {
    if (node == null) {
        return false;
    }
    if (equals(target, node.value)) {
        return true;
    }
    if (containsValueHelper(node.left, target)) {
        return true;
    }
    if (containsValueHelper(node.right, target)) {
        return true;
    }
    return false;
}
\end{verbatim}

\java{containsValue} toma el valor objetivo como un parámetro e
invoca inmediatamente a \java{containsValueHelper}, pasando la raíz
del árbol como un parámetro adicional.

\index{caso base}
\index{recursió}

Así es cómo funciona \java{containsValueHelper}:

\begin{itemize}

\item
  La primera instrucción \java{if} comprueba el caso base de la recursión.
  Si \java{node} es \java{null}, eso significa que hemos llegado hasta la
  parte inferior del árbol sin encontrar el \java{target}, así que deberíamos
  devolver \java{false}. Nota que esto sólo implica que el objetivo no
  aparecía en una ruta del árbol; aún es posible que sea encontrado en otra.

\item
  El segundo caso comprueba si hemos encontrado lo que estamos buscando. De ser
  así, devolveríamos \java{true}. De otra manera, tenemos que continuar.

\item
  El tercer caso realiza una llamada recursiva a la búsqueda para \java{target} en
  el subárbol izquierdo. Si lo encontramos, podemos devolver \java{true}
  inmediatamente, sin tener que buscar en el subárbol derecho. De lo contrario,
  seguimos.

\item
  El cuarto caso busca en el subárbol derecho. De nuevo, si encontramos lo que
  estamos buscando, devolvemos \java{true}. De lo contrario, tras haber buscado
  en todo el árbol, devolvemos \java{false}.

\end{itemize}

Este método ``visita'' cada nodo en el árbol, así que toma tiempo
proporcional al número de nodos.

\index{tiempo lineal}


\section{Implementación de {\tt put}}
\label{implementing-put}

El método \java{put} es un poco más complicado que \java{get}
porque tiene que lidiar con dos casos: (1) si la clave dada ya
está en el árbol, la reemplaza y devuelve el valor antiguo; (2) de lo
contrario tiene que agregar un nuevo nodo al árbol, en el lugar correcto.

\index{put}

En el ejercicio anterior, proveía este código inicial:

\begin{verbatim}
public V put(K key, V value) {
    if (key == null) {
        throw new IllegalArgumentException();
    }
    if (root == null) {
        root = new Node(key, value);
        size++;
        return null;
    }
    return putHelper(root, key, value);
}
\end{verbatim}

Y te pedí que llenaras \java{putHelper}. Aquí está mi solución:

\begin{verbatim}
private V putHelper(Node node, K key, V value) {
    Comparable<? super K> k = (Comparable<? super K>) key;
    int cmp = k.compareTo(node.key);

    if (cmp < 0) {
        if (node.left == null) {
            node.left = new Node(key, value);
            size++;
            return null;
        } else {
            return putHelper(node.left, key, value);
        }
    }
    if (cmp > 0) {
        if (node.right == null) {
            node.right = new Node(key, value);
            size++;
            return null;
        } else {
            return putHelper(node.right, key, value);
        }
    }
    V oldValue = node.value;
    node.value = value;
    return oldValue;
}
\end{verbatim}

\index{subárbol}

El primer parámetro, \java{node}, es inicialmente la raíz del árbol,
pero cada vez que hacemos una llamada recursiva, se refiere un subárbol
diferente. Como en \java{get}, usamos el método \java{compareTo} para
decidir qué ruta seguir en el árbol. Si \java{cmp < 0}, la clave que
estamos agregando es menor que \java{node.key}, así que queremos buscar
en el subárbol izquierdo. Aquí hay dos casos:

\begin{itemize}

\item
  Si el subárbol izquierdo está vacío, es decir, si \java{node.left} es
  \java{null}, hecmos alcanzado la parte inferior del árbol sin encontrar a
  \java{key}. En este punto, sabemos que \java{key} no está en el árbol
  y sabemos dónde debería ir. Así que creamos un nuevo nodo y lo agregamos
  como el hijo izquierdo de \java{node}.

\item
  De lo contarior, hacemos una llamada recursiva para buscar en el subárbol izquierdo.

\end{itemize}

Si \java{cmp > 0}, la clave que estamos agregando es mayor que
\java{node.key}, así que queremos buscar en el subárbol derecho. Y se
tienen los mismo dos casos que en la rama anterior.
Finalmente, si \java{cmp == 0}, encontramos la clave en el árbol, así que
la reemplazamos y devolvemos el valor antiguo.

\index{iterativo}

Escribí este método recursivamente para hacerlo más legible, pero debería
ser sencillo reescribirlo de forma iterativa, lo que podrías querer
hacer como un ejercicio.


\section{Recorrido en orden}
\label{in-order-traversal}

El último método que te pedí escribir es \java{keySet}, que devuelve
un \java{Set} que contiene las claves del árbol en orden ascendente.
En otras implementaciones de \java{Map}, las claves devueltas por
\java{keySet} no están en ningún orden particular, pero una de las 
características de la implementación de árbol es que es simple y eficiente
ordenar las claves. Así que deberíamos aprovechar eso.

\index{en orden}
\index{recorrido de árboles}
\index{keySet}

Aquí está mi solución:

\begin{verbatim}
public Set<K> keySet() {
    Set<K> set = new LinkedHashSet<K>();
    addInOrder(root, set);
    return set;
}

private void addInOrder(Node node, Set<K> set) {
    if (node == null) return;
    addInOrder(node.left, set);
    set.add(node.key);
    addInOrder(node.right, set);        
}
\end{verbatim}

En \java{keySet}, creamos un \java{LinkedHashSet}, que es una
implementación de \java{Set} que mantiene los elementos en orden (a diferencia
de la mayoría de las demás implmentaciones de \java{Set}). Luego llamamos a
\java{addInOrder} para recorrer el árbol.

\index{LinkedHashSet}

El primer parámetro, \java{node}, es inicialmente la raíz del árbol,
pero como deberías esperar por ahora, la usamos para navegar por el árbol
de forma recursiva. \java{addInOrder} realiza un clásico ``recorrido
en orden'' del árbol.

Si el \java{node} es \java{null}, significa que el subárbol está vacío, así que
nos salimos sin agregar nada al \java{set}. De lo contrario:

\begin{enumerate}

\item
  Recorre el subárbol izquierdo en orden.

\item
  Agrega \java{node.key}.

\item
  Navega por el subárbol derecho en orden.

\end{enumerate}

Recuerda que la propiedad ABB garantiza que todos los nodos en el subárbol
izquierdo son menores que \java{node.key}, y todos los nodos en el subárbol derecho
son mayores. Así que sabemos que \java{node.key} ha sido agregado en el orden
correcto.

\index{propiedad ABB}
\index{recursión}
\index{caso base}

Al aplicar el mismo argumento recursivamente, sabemos que los elementos del
subárbol izquierdo están en orden, así como los elementos del subárbol
derecho. Y el caso base es correcto: si el subárbol está vacío, no se
agregan claves. Así que podemos concluir que este método agrega todas las
claves en el orden correcto.

Porque este método visita cada nodo en el árbol, como
\java{containsValue}, toma tiempo proporcional a $n$.


\section{Los métodos logarítmicos}
\label{the-logarithmic-methods}

En \java{MyTreeMap}, los métodos \java{get} y \java{put} toman
tiempo proporcional a la altura del árbol, $h$. En el ejercicio
anterior, mostramos que si el árbol está lleno --- si cada nivel del
árbol contiene el máximo número de nodos --- la altura del árbol es
proporcional a $\log n$.

\index{tiempo logarítmico}
\index{get}
\index{put}

Y afirmé que \java{get} y \java{put} son logarítmicos; es decir,
toman tiempo proporcional a $\log n$. Pero para la mayoría de
aplicaciones, no hay garantías que el árbol esté llenon. En general,
la forma del árbol depende de las claves y el orden en que se agreguen.

Para ver cómo esto funciona en la práctica, probaremos nuestra implementación
con dos conjuntos de datos de ejemplo: una lista de cadenas al azar y una
lista de marcas de tiempo (timestamps) en orden ascendente.

\index{perfilado}

Aquí está el código que genera cadenas al azar:

\begin{verbatim}
Map<String, Integer> map = new MyTreeMap<String, Integer>();

for (int i=0; i<n; i++) {
    String uuid = UUID.randomUUID().toString();
    map.put(uuid, 0);
}
\end{verbatim}

\java{UUID} es una clase en el paquete \java{java.util} que puede
generar un ``identificador universalmente único'' al azar. Los UUIDs son
útiles para una variedad de aplicaciones, pero en este ejemplo tomamos
ventaja de una forma fácil para generar cadenas al azar.

\index{UUID}

Ejecuté este código con \java{n=16384} y medí el tiempo de ejecución
y la altura del árbol final. Aquí está la salida:

\begin{verbatim}
Time in milliseconds = 151
Final size of MyTreeMap = 16384
log base 2 of size of MyTreeMap = 14.0
Final height of MyTreeMap = 33
\end{verbatim}

Incluí ``log base 2 of size of MyTreeMap'' (logaritmo base 2 del tamaño de
MyTreeMap) para ver qué tan alto sería el árbol si estuviera lleno. El
resultado indica que un árbol lleno con altura 14 contendría 16,384 nodos.

El árbol real de cadenas al azar tiene altura 33, que es sustancialmente
mayor a la altura teórica mínima, pero no está mal. Para encontrar una
clave en un colección de 16,348, sólo tenemos que hacer 33 comparaciones.
Con respecto a una búsqueda lineal, es casi 500 veces más rápida.

\index{búsqueda lineal}

Este desempeño es típico para cadenas al azar u otras claves que no
agregan en ningún orden particular. La altura final del árbol podría ser
2-3 veces el mínimo teórico, pero todavía es proporcional a
$\log n$, que es mucho menor que $n$. De hecho,
$\log n$ crece tan lento conforme $n$ se incrementa, que puede ser
difícil distinguir tiempo logarítmico de tiempo constante en la
práctica.

\index{tiempo constante}
\index{tiempo logarítmico}
\index{timestamp}

Sin embargo, los árboles binarios de búsqueda no siempre se comportan tan bien.
Veamos lo que sucede cuando agregamos claves en orden ascendente. Aquí está un
ejemplo que mide marcas de tiempo en nanosegundos y las usa como claves:

\begin{verbatim}
MyTreeMap<String, Integer> map = new MyTreeMap<String, Integer>();

for (int i=0; i<n; i++) {
    String timestamp = Long.toString(System.nanoTime());
    map.put(timestamp, 0);
}
\end{verbatim}

\java{System.nanoTime} devuelve un entero de tipo \java{long} que
indica el tiempo transcurrido en nanosegundos. Cada vez que lo llamamos,
obtenemos un número más grande. Cuando convertimos estas marcas de
tiempo a cadenas, aparecen en orden alfabético ascendente.

Y veamos lo que ocurre cuando lo ejecutamos:

\begin{verbatim}
Time in milliseconds = 1158
Final size of MyTreeMap = 16384
log base 2 of size of MyTreeMap = 14.0
Final height of MyTreeMap = 16384
\end{verbatim}

El tiempo de ejecución es más de siete veces más largo que el del caso
anterior. Si te preguntas por qué, mira la altura final del árbol: ¡16384!

\begin{figure}
\centering
\includegraphics[width=4in]{figs/bst.pdf}
\caption{Árboles binarios de búsqueda, balanceado (izquierda) y desbalanceado (derecha).}
\label{bstfig}
\end{figure}

Si piensas en cómo funciona \java{put}, puedes entender lo que ocurre.
Cada vez que agregamos una nueva clave, es mayor que todas las demás
claves en el árbol, así que siempre elegimos el subárbol derecho y siempre
agregamos el nuevo nodo como el hijo derecho del nodo más a la dercha. El
resultado es un árbol ``desbalanceado'' que sólo contiene hijos a la derecha.

\index{árbol desbalanceado}
\index{árbol balanceado}

La altura de este árbol es proporcional a $n$, no
$\log n$, así que el desempeño de \java{get} y \java{put} es
lineal, no logarítmico.

\index{tiempo lineal}

La figura~\ref{bstfig} muestra un ejemplo de un árbol balanceado y un
árbol desbalanceado. En el árbol balanceado, la altura es 4 y el número
total de nodos es $2^4-1 = 15$.  En el árbol desbalanceado con el mismo
número de nodos, la altura es 15.


\section{Árboles auto-balanceables}
\label{self-balancing-trees}

\index{árboles auto-balanceables}

Hay dos posibles soluciones para este problema:

\begin{itemize}

\item
  Puedes evitar agregar claves al \java{Map} en orden. Pero esto
  no siempre es posible.

\item
  Puedes hacer un árbol que haga un mejor trabajo al manejar claves
  si se da el caso que están en orden.

\end{itemize}

La segunda solución es mejor y hay varias maneras de hacerlo. La más
común es modificar \java{put} para que detecte cuando el árbol está
comenzando a desbalancearse y, de ser así, reacomode los nodos. Los
árboles con esta habilidad se llaman ``auto-balanceables''. Los árboles
auto-balanceables comunes incluye el árbol AVL (``AVL'' son las iniciales
de sus inventores) y el árbol rojo-negro, que es el que el \java{TreeMap}
de Java usa.

\index{árbol AVL}
\index{árbol rojo-negro}

En nuestro código de ejemplo, si reemplazamos \java{MyTreeMap} con el 
\java{TreeMap} de Java, los tiempos de ejecución son casi iguales para
cadenas aleatorias y para marcas de tiempo. De hecho, las marcas de tiempo
se ejecutan incluso más rápido, aunque están en orde, probablemente porque
necesitan menos tiempo para codificarse (hash).

\index{tiempo logarítmico}

En resumen, un árbol binario de búsqueda puede implementar \java{get} y
\java{put} en tiempo logarítmico, pero solo si las claves se agregan en un
orden que mantenga al árbol lo suficientemente balanceado. Los árboles
auto-balanceables previenen este problema realizando trabajo adicional cada
vez que se agrega una nueva clave.

Puedes leer más sobre árboles auto-balanceables en
\url{http://thinkdast.com/balancing}.


\section{Un ejercicio más}
\label{one-more-exercise}

En el ejercicio anterior no tuviste que implementar \java{remove},
pero podrías querer intentarlo. Si remueves un nodo de la mitad del
árbol, debes reacomodar los nodos restantes para restaurar la propiedad
ABB. Probablemente puedas deducir cómo hacer eso por tu cuenta, o puedes
leer la explicación en
\url{http://thinkdast.com/bstdel}.

\index{remove}

Remover un nodo y rebalancear un árbol son operaciones similares: si haces
este ejercicio, tendrás una mejor idea de cómo funcionan los árboles
auto-balanceables.



\chapter{Persistencia}

En los siguientes ejercicios regresaremos a la construcción de un motor
de búsqueda web. Para recordar, los componentes de un motor de búsqueda son:

\begin{itemize}

  \item
  Rastrear: Necesitaremos un programa que pueda descargar una página, interpretarla
  y extraer el texto y cualquier enlace a otras páginas.

  \item
  Indexar: Necesitaremos un índice que haga posible buscar un término
  de búsqueda y encontrar las páginas que lo contienen.

  \item
  Recuperar: Y necesitaremos una forma de recolectar los resultados del Index e identificar
  las páginas que son más relevantes para los términos de búsqueda.

\end{itemize}

\index{motor de búsqueda}
\index{rastreador}
\index{indexador}
\index{recuperador}

Si hiciste el Ejercicio~\ref{exercise6}, implementaste un índice utilizando
mapas de Java. En este ejercicio, vamos a revisar el indexador y haremos
una nueva versión que guarde los resultados en una base de datos.

\index{indexador}

Si hiciste el Ejercicio~\ref{exercise5}, construiste un rastreador
que siga el primer enlace que encuentra. En el siguiente ejercicio,
haremos una versión más general que guarde cada enlace que encuentra
en una cola y los explore en orden.

Y luego, finalmente, trabajaremos en el problema de la recuperación.

En estos ejercicios, proveo menos código de inicio, y tendrás que hacer
más decisiones de diseño. Estos ejercicios también son más abiertos. Sugeriré
algunas metas mínimas que deberías tratar de alcanzar, pero hay muchas formas
de lograr mejores resultados si quieres desafiarte a ti mismo.

Ahora, comencemos con la nueva versión del indexador.

\section{Redis}
\label{redis}

\index{Redis}

La versión anterior del indexador guarda el índice en dos estructuras
de datos: un \java{TermCounter} que mapea términos de búsqueda con el
númerro de veces que aparecen en una página web y un \java{Index} que
mapea un término de búsqueda con el conjunto de páginas donde aparece.

Estas estructuras de datos se guardan en la memoria de un programa de
Java en ejecución, lo que significa que cuando el programa se detiene, el
índice se pierde. A los datos guardados sólo en la memoria de un programa
en ejecución se les llama ``volátiles'', porque se vaporizan cuando el
programa finaliza.

\index{volátil}
\index{persistente}

Los datos que persisten después que el programa que los creó finaliza son
llamados ``persistentes''. En general, los archivos guardados en un sistema de
archivos son persistentes, así como los datos guardados en bases de datos.

\index{JSON}

Una forma simple de hacer un dato persistente es guardarlo en un archivo. Antes
que el programa finalice, podría traducir sus estructuras de datos en un formato
como JSON (\url{http://thinkdast.com/json}) y luego escribirlos en un
archivo. Cuando inicia de nuevo, podría leer el archivo y reconstruir las
estructuras de datos.

Pero hay varios problemas con esta solución:

\begin{enumerate}
\item
  Leer y escribir estructuras de datos de gran tamaño (como un índice Web)
  sería lento.

\item
  La estructura de datos completa podría no caber en la memoria de un
  programa individual en ejecución.

\item
  Si un programa finaliza de forma inesperada (por ejemplo, debido a un apagón)
  cualquier cambio hecho desde que el programa se inició por última vez se perdería.

\end{enumerate}

Una mejor alternativa es usar una base de datos que provee almacenamiento
persistente y la habilidad de leer y escribir partes de la base de datos sin
tener que leer y escribir todo.

\index{base de datos}
\index{DBMS}

Hay muchos tipos de sistemas de adminitración de bases de datos (DBMS) que proveen
diferentes características. Puedes leer una introducción en
\url{http://thinkdast.com/database}.

\index{Redis}

La base de datos que recomiendo para este ejercicio es Redis, que provee
estructuras de datos persistentes que son similares a las estructuras de
datos de Java. Específicamente, provee:

\begin{itemize}

\item
  Lista de cadenas, similar a la \java{List} de Java.

\item
  Hashes, similar al \java{Map} de Java.

\item
  Conjunto de cadenas, similar al \java{Set} de Java.

\end{itemize}

Redis en una ``base de datos clave-valor'', que significa que las estructuras
de datos que contiene (los valores) se identifican con cadenas únicas (las
claves). Una clave en Redis juega el mismo rol que una referencia en Java:
identifica un objeto. Veremos algunos ejemplos pronto.

\index{base de datos clave-valor}


\section{Clientes y servidores de Redis}
\label{redis-clients-and-servers}

\index{cliente}
\index{servidor}

Redis usualmente se ejecuta como un servicio remoto; de hecho, el nombre
significa ``REmote DIctionary Server'' (``Servicio de DIccionario REmoto''). 
Para usar Redis, tienes que ejecutar el servidor Redis en algún lugar y conectarte
a él utilizando un cliente Redis. Hay muchas formas de configurar un servidor
y muchos clientes que puedes usar. Para este ejercicio, recomiendo:

\begin{enumerate}

\item
  En lugar de instalar y ejecutar el servidor tú mismo, considera usar un
  servicio como RedisToGo (\url{http://thinkdast.com/redistogo}), que ejecuta
  Redis en la nube. Ellos ofrecen un plan gratuito con suficientes recursos
  para este ejercicio.

\item
  Para el cliente recomiendo Jedis, que es una biblioteca de Java que
  provee clases y métodos para trabajar con Redis.

\end{enumerate}

\index{RedisToGo}
\index{Jedis}

Aquí hay instrucciones detalladas para ayudarte a comenzar:

\begin{itemize}

\item Crear una cuenta en RedisToGo, en
  \url{http://thinkdast.com/redissign},
  y selecciona el plan que quieres (probablemente el plan gratuito para comenzar).

\item
  Crea una ``instancia'', que es una máquina virtual ejecutando el servidor
  Redis. Si haces clic en la pestaña ``Instancias'', deberías ver tu nueva
  instnacia, identificada con un nombre de host y un número de puerto. Por ejemplo,
  yo tengo una instancia llamada ``dory-10534''.

\item
  Haz clic en el nombre de la instancia para ir a la página de configuración. Anota
  la URL cerca de la página superior de la página, que se ve algo así:

  \begin{verbatim}
  redis://redistogo:1234567feedfacebeefa1e1234567@dory.redistogo.com:10534
  \end{verbatim}

\end{itemize}

\index{instancia de Redis}

Esta URL contiene el nombre de host del servidor, \java{dory.redistogo.com},
el número de puerto, \java{10534}, y la constraseña que necesitarás para
conectarte al servidor, que es la cadena larga de letras y números en el
medio. Necesitarás esta información para el siguiente paso.


\section{Hacer un índice respaldado por Redis}
\label{hello-jedis}

\index{JedisMaker}
\index{JedisIndex}
\index{WikiFetcher}

En el repositorio para esta libro,
encontrarás el código fuente para este ejercicio:

\begin{itemize}

\item
  \java{JedisMaker.java} contiene código de ejemplo para conectarse a un
  servidor Redis y ejecutar algunos métodos de Jedis.

\item
  \java{JedisIndex.java} contiene código inicial para este ejercicio.

\item
  \java{JedisIndexTest.java} contiene código de pruebas para
  \java{JedisIndex}.

\item
  \java{WikiFetcher.java} contiene el código que vimos en los ejercicios anteriores para
  ler páginas web e interpretarlas usando jsoup.

\end{itemize}

También necesitarás estos archivos, en los que trabajaste en ejercicios
anteriores:

\begin{itemize}

\item
  \java{Index.java} implementa un índice usando estructuras de datos de Java.

\item
  \java{TermCounter.java} representa un mapa de los términos con sus
  frecuencias.

\item
  \java{WikiNodeIterable.java} itera por los nodos en un árbol DOM
  producido por jsoup.

\end{itemize}

Si tienes versiones funcionales de estos archivos, puedes usarlas para
este ejercicio.  Si no hiciste los ejercicios anteriores, o si
no confías en tus soluciones, puedes copiar mis soluciones desde el
directorio {\tt solutions}.

El primer paso es usar Jedis para conectarte a tu servidor Redis.
\java{RedisMaker.java} muestra cómo hacer esto. Este archivo lee información
sobre tu servidor Redis de un archivo, se conecta a él e inicia sesión
usando tu contraseña, luego devuelve un objeto \java{Jedis} que puedes usar
para realizar operaciones en Redis.

\index{clase auxiliar}

Si abres \java{JedisMaker.java}, deberías ver la clase
\java{JedisMaker}, que es una clase auxiliar que provee un método
estático, \java{make}, la cual crea un objeto \java{Jedis} object. Una
vez este objeto se ha autenticado, puedes usarlo para comunicarte con tu
base de datos Redis.

\java{JedisMaker} lee información sobre tu servidor redis de un archivo
llamado \java{redis_url.txt}, que debes colocar en el directorio
\java{src/resources}:

\begin{itemize}

\item
  Usa un editor de texto para crear y editar
  \java{ThinkDataStructures/code/src/resources/redis_url.txt}.

\item
  Pega la URL de tu servidor. Si estás usando RedisToGo, la URL
  se verá así:

\java{redis://redistogo:1234567feedfacebeefa1e1234567@dory.redistogo.com:10534}

\end{itemize}

Porque este archivo contiene la contraseña de tu servidor Redis, no
deberías ponerlo en un repositorio publico. Para ayudarte a prevenir
hacerlo por accidente, el repositorio contiene un archivo {\tt .gitignore}
que hace más difícil (pero no imposible) poner este archivo en tu repo.

\index{Ant}

Ahora ejecuta \java{ant build} para compilar los archivos de
código fuente y \java{ant JedisMaker} para ejecutar el código de ejemplo en
\java{main}:

\begin{verbatim}
    public static void main(String[] args) {

        Jedis jedis = make();
        
        // String
        jedis.set("mykey", "myvalue");
        String value = jedis.get("mykey");
        System.out.println("Got value: " + value);
        
        // Set
        jedis.sadd("myset", "element1", "element2", "element3");
        System.out.println("element2 is member: " + 
                           jedis.sismember("myset", "element2"));
        
        // List
        jedis.rpush("mylist", "element1", "element2", "element3");
        System.out.println("element at index 1: " + 
                           jedis.lindex("mylist", 1));
        
        // Hash
        jedis.hset("myhash", "word1", Integer.toString(2));
        jedis.hincrBy("myhash", "word2", 1);
        System.out.println("frequency of word1: " + 
                           jedis.hget("myhash", "word1"));
        System.out.println("frequency of word1: " + 
                            jedis.hget("myhash", "word2"));
        
        jedis.close();
    }
\end{verbatim}

Este ejemplo demuestra los tipos de datos y métodos que probablemente uses
en este ejercicio. Cuando lo ejecutes, la salida debería ser:

\begin{verbatim}
Got value: myvalue
element2 is member: true
element at index 1: element2
frequency of word1: 2
frequency of word2: 1
\end{verbatim}

En la siguiente sección, explicaré cómo funciona el código.


\newcommand{\redis}{\textit}

\section{Tipos de datos de Redis}
\label{redis-data-types}

Redis es básicamente un mapa de las claves, que son cadenas, a
valores, que pueden ser uno de varios tipos de datos. El tipo de
datos más básico en Redis es una \redis{string}.  Escribiré los tipos
de Redis en cursiva para distinguirlos de los tipos de Java.

Para agregar una \redis{string} a la base de datos,
usaremos \java{jedis.set}, que es similar a \java{Map.put}; los
parámetros son la nueva clave y el valor correspondiente. Para buscar
una clave y obtener su valor, usamos \java{jedis.get}:

\begin{verbatim}
        jedis.set("mykey", "myvalue");
        String value = jedis.get("mykey");
\end{verbatim}

En este ejemplo, la clave es \java{"mykey"} y el valor es
\java{"myvalue"}.

\index{set de Redis}
\index{get de Redis}

Redis provee una estructura \redis{set}, similar a un
\java{Set<String>} de Java. Para añadir elementos a un \redis{set} de Redis,
eliges una clave para identificar el \redis{set} y luego usas
\java{jedis.sadd}:

\begin{verbatim}
        jedis.sadd("myset", "element1", "element2", "element3");
        boolean flag = jedis.sismember("myset", "element2");
\end{verbatim}

No tienes que crear el \redis{set} en un paso separado. Si no existe,
Redis lo crea. En este caso, crea un \redis{set} llamado \java{myset}
que contiene tres elementos.

El método \java{jedis.sismember} comprueba si un elemento está en un
\redis{set}. Agregar elementos y comprobar la membresía son operaciones
de tiempo constante.

\index{tiempo constante}

Redis también provee una estructura \redis{list} similar a una
\java{List<String>} de Java. El método
\java{jedis.rpush} agrega elementos al final (lado derecho) de una
\redis{list}:

\begin{verbatim}
        jedis.rpush("mylist", "element1", "element2", "element3");
        String element = jedis.lindex("mylist", 1);
\end{verbatim}

De nuevo, no tienes que crear la estrucutura antes de empeza a agregar
elementos. Este ejemplo crea una \redis{list} llamada ``mylist'' que
contiene tres elementos.

\index{list de Redis}
\index{hash de Redis}

El método \java{jedis.lindex} toma un índice entero y devuelve el
elemento indicado de una \redis{list}. Agregar y acceder elementos son
operaciones de tiempo constante.

Finalmente, Redis provee una estructura \redis{hash}, similar a un
\java{Map<String, String>} de Java. El método
\java{jedis.hset} añade una nueva entrada al \redis{hash}:

\begin{verbatim}
        jedis.hset("myhash", "word1", Integer.toString(2));
        String value = jedis.hget("myhash", "word1");
\end{verbatim}

Este ejemplo crea un \redis{hash} llamado \java{myhash} que contiene una
entrada, la cual mapea la clave \java{word1} con el valor \java{"2"}.

Las claves y los valores son \redis{string}s, así que si queremos guardar
un \java{Integer}, tenemos que convertirlo a una
\java{String} antes de llamar a \java{hset}. 
Y cuando busquemos el valor usando \java{hget},
el resultado es un \java{String}, así que puede que tengamos que convertirlo
de vuelta a un \java{Integer}.

\index{campo}

Trabajar con los \redis{hash}es de Redis puede ser confuso, porque usamos una clave para
identificar el \redis{hash} que queremos, y luego otra clave para identificar un valor en
el \redis{hash}. En el contexto de Redis, la segunda clave es llamada un ``campo'',
que podría ayudarnos a mantener las cosas en orden. Así que una ``clave'' como \java{myhash}
identifica un \redis{hash} particular, y luego un ``campo'' como \java{word1}
identifica un valor en el \redis{hash}.

Para muchas aplicaciones, los valores en un \redis{hash} de Redis son enteror, por lo que Redis
provee unos cuantos métodos especiales, como \java{hincrby}, que tratan a los valores como
números:

\begin{verbatim}
        jedis.hincrBy("myhash", "word2", 1);
\end{verbatim}

Este método accede a \java{myhash}, obtiene el valor actual asociado
con \java{word2} (o 0 si no existe), lo incrementa en
1, y escribe el resultado de regreso en el \redis{hash}.

Actualizar, obtener e incrementar entradas en un \redis{hash} son operaciones de
tiempo constante.

\index{tiempo constante}
\index{tipo de datos de Redis}

Puedes leer más sobre los tipos de datos de Redis en
\url{http://thinkdast.com/redistypes}.


\section{Ejercicio 11}
\label{exercise11}

En este punto, ya tienes la información que necesitas para hacer un índice
de búsqueda web que guarde los resultados en una base de datos Redis.

\index{JedisIndex}

Ahora ejecuta \java{ant JedisIndexTest}. Debería
fallar, ¡porque tienes algo de trabajo por hacer!

\java{JedisIndexTest} prueba estos métodos:

\begin{itemize}

\item
  \java{JedisIndex}, que es el constructor que toma un
  objeto \java{Jedis} como parámetro.

\item
  \java{indexPage}, que agrega una página Web al índice; toma una URL de
  tipo \java{String} y un objeto \java{Elements} de jsoup que contiene los
  elementos de la página que deberían ser indexados.

\item
  \java{getCounts}, que toma un término de búsqueda y devuelve un
  \java{Map<String, Integer>} que mapea cada
  URL que contiene el término de búsqueda con el número de veces que
  éste aparece en dicha página.

\end{itemize}

Aquí está un ejemplo de cómo usar estos métodos:

\begin{verbatim}
        WikiFetcher wf = new WikiFetcher();
        String url1 = 
            "http://en.wikipedia.org/wiki/Java_(programming_language)";
        Elements paragraphs = wf.readWikipedia(url1);

        Jedis jedis = JedisMaker.make();
        JedisIndex index = new JedisIndex(jedis);
        index.indexPage(url1, paragraphs);
        Map<String, Integer> map = index.getCounts("the");
\end{verbatim}

Si buscamos \java{url1} en el resultado, \java{map}, deberíamos obtener
339, que es el número de veces que la palabra ``the'' aparece en la
página de Wikipedia para Java (es decir, en la versión que guardamos).

\index{WikiFetcher}

Si indexamos la misma página de nuevo, los nuevos resultados deberían
reemplazar a los antiguos.

Una sugerencia para traducir estructuras de datos de Java a Redis:
recuerda que cada objeto en una base de datos Redis se identifica con una
clave única, que es una \redis{string}. Si tienes dos clases de objetos en la
misma base de datos, podrías querer agregar un prefijo a las claves para
distinguirlos. Por ejemplo, en nuestra solución, tenemos dos clases de
objetos:

\begin{itemize}

\item
  Definimos un \java{URLSet} como un \redis{set} de Redis que contiene
  las URLs que contienen un término de búsqueda dado. La clave para cada
  \java{URLSet} comienza con \java{"URLSet:"}, así que para obtener las
  URLs que contienen la palabra ``the'', accedemos al \redis{set} con la
  clave \java{"URLSet:the"}.

\item
  Definimos un \java{TermCounter} como un \redis{hash} de Redis que mapea
  cada término que aparece en una página con el número de veces que
  aparece. La clave para cada \java{TermCounter} comienza con
  \java{"TermCounter:"} y finaliza con la URL de la página que buscamos.

\end{itemize}

\index{URLSet}
\index{TermCounter}

En mi implementación,  hay un \java{URLSet} para cada término y un
\java{TermCounter} para cada página indexada. Proveo dos métodos
auxiliares, \java{urlSetKey} y \java{termCounterKey}, para juntar
estas claves.

\index{método auxiliar}


\section{Más sugerencias si las quieres}
\label{more-suggestions-if-you-want-them}

Llegados a este punto tienes toda la información que necesitas para hacer el
ejercicio, así que puedes iniciar si estás listo. Pero tengo unas cuantas
sugerencias que podrías querer leer primero:

\begin{itemize}

\item
  Para este ejercicio proveo menos guía que para los ejercicios
  precios. Tendrás que tomar algunas decisiones de diseño, en
  particular, tendrás que ingeniártelas para dividir el problema
  en partes que puedes probar una por una, y luego ensamblar las
  piezas en una solución completa. Si tratas de escribir todo de
  una sola vez, sin probar fragmentos pequeños, la depuración
  podría tomarte un largo tiempo.

\item
  Uno de los desafíos de trabajar con datos persistentes es que son
  persistentes. Las estructuras guardadas en la base de datos podrían
  cambiar cada vez que ejecutes el programa. Si arruinas algo en la base de
  datos, tendrás que arreglarlo o comenzar de cero antes de proceder. Para 
  ayudarte a mantener las cosas bajo control, he provisto métodos llamados
  \java{deleteURLSets}, \java{deleteTermCounters}, y
  \java{deleteAllKeys}, que puedes usar para limpiar la base de datos y
  comenzar de nuevo. También puedes usar \java{printIndex} para imprimir los
  contenidos de un índice.

\item
  Cada vez que invoques un método de \java{Jedis}, tu cliente envía un
  mensaje al servidor, luego el servidor realiza la acción que le pediste
  y envía un mensaje de vuelta. Si realizas muchas operaciones pequeñas,
  probablemente se demore mucho. Puedes mejorar el desempeño al agrupar
  un serie de operaciones en una \java{Transaction}.

\end{itemize}

Por ejemplo, aquí está una versión simple de \java{deleteAllKeys}:

\begin{verbatim}
    public void deleteAllKeys() {
        Set<String> keys = jedis.keys("*");
        for (String key: keys) {
            jedis.del(key);
        }
    }
\end{verbatim}

Cada vez que invocas a \java{del} se requiere un viaje de ida y vuelta del cliente
al servidor. Si el índice contiene más que unas cuantas páginas, este método
utilizará una larga cantidad de tiempo para ejecutarse. Podemos acelerarlo con
un objeto \java{Transaction}:

\index{servidro}

\begin{verbatim}
    public void deleteAllKeys() {
        Set<String> keys = jedis.keys("*");
        Transaction t = jedis.multi();
        for (String key: keys) {
            t.del(key);
        }
        t.exec();
    }
\end{verbatim}

\java{jedis.multi} devuelve un objeto \java{Transaction}, que provee
todos los métodos de un objeto \java{Jedis}. Pero cuando invocas un
método en una \java{Transaction}, la operación no se ejecuta de inmediato
y no se comunica con el servidor. En su lugar, almacena un lote de operaciones
hasta que invocas \java{exec}. Luego envía todas las operaciones almacenadas
al servidor al mismo tiempo, lo que usualmente es mucho más rápido.

\index{Transaction}



\section{Unos cuantos tips de diseño}
\label{a-few-design-hints}

Ahora sí \emph{realmente} tienes todas la información que necesitas; deberías
comenzar a trabajar en el ejercico. Pero si te atascas, o si de verdad no sabes
cómo comenzar, puedes regresar por más pistas.

\textbf{No leas lo siguientes hasta que hayas ejecutado el código de pruebas, 
probado algunos comandos básicos de Redis y escrito unos cuantos métodos en
\java{JedisIndex.java}}.

OK, si realmente estás atascado, aquí están algunos métodos en los que podrías
querer trabajar:

\begin{verbatim}
    /**
     * Agrega una URL al set asociado con el término.
     */
    public void add(String term, TermCounter tc) {}

    /**
     * Busca un término de búsqeuda y devuelve un set de URLs.
     */
    public Set<String> getURLs(String term) {}

    /**
     * Devuelve el número de veces que el término dado
     * aparece en la URL proporcionada.
     */
    public Integer getCount(String url, String term) {}

    /**
     * Agrega los contenidos del TermCounter a Redis.
     */
    public List<Object> pushTermCounterToRedis(TermCounter tc) {}
\end{verbatim}

Estos son los métodos que usé en mi solución, pero ciertamente no
son la única manera de dividir el trabajo. Así que por favor toma
estas sugerencias si te sirven, pero ignóralas si no.

Para cada método, considera escribir los tests primero. Cuando decides
cómo probar un método, muchas veces se te ocurren ideas para escribirlo.

¡Buena suerte!



\chapter{Rastreo de Wikipedia}

En este capítulo, presento una solución al ejercicio previo y
analizo el desempeño de los algoritmos de indexación Web. Luego
construimos un rastreador Web simple.

\section{El indexador respaldado por Redis}
\label{redis-indexer}

\index{Redis}
\index{URLSet}
\index{TermCounter}

En mi solución, guardamos dos clases de estructuras en Redis:

\begin{itemize}

\item
  Para cada término de búsqueda, tenemos un \java{URLSet}, que es un \redis{set} de Redis
  de URLs que contienen el término de búsqueda.

\item
  Para cada URL, tenemos un \java{TermCounter}, que es un \redis{hash} de Redis
  que mapea cada término de búsqueda con el número de veces que aparece.

\end{itemize}

Discutimos estos tipos de datos en el capítulo previo. También puedes
leer sobre la estructuras de Redis en \url{http://thinkdast.com/redistypes}

\index{JedisIndex}

En \java{JedisIndex}, proveo métodos que toman un término de búsqueda y
devuelven la clave Redis de su \java{URLSet}:

\begin{verbatim}
private String urlSetKey(String term) {
    return "URLSet:" + term;
}
\end{verbatim}

Y un método que toma una URL y devuelve la clave Redis de su
\java{TermCounter}:

\begin{verbatim}
private String termCounterKey(String url) {
    return "TermCounter:" + url;
}
\end{verbatim}

Aquí está la implementación de \java{indexPage}, que toma una URL y un objeto which takes a URL and a
\java{Elements} de jsoup que contiene el árbol DOM de los párrafos que queremos indexar:

\begin{verbatim}
public void indexPage(String url, Elements paragraphs) {
    System.out.println("Indexing " + url);

    // make a TermCounter and count the terms in the paragraphs
    TermCounter tc = new TermCounter(url);
    tc.processElements(paragraphs);

    // push the contents of the TermCounter to Redis
    pushTermCounterToRedis(tc);
}
\end{verbatim}

Para indexar una página,

\begin{enumerate}

\item
  Creamos un \java{TermCounter} de Java para los contenidos de la página, usando
  el código del ejercicio anterior.

\item
  Agregamos los contenidos del \java{TermCounter} a Redis.

\end{enumerate}

Aquí está el nuevo código que agrega un \java{TermCounter} a Redis:

\begin{verbatim}
public List<Object> pushTermCounterToRedis(TermCounter tc) {
    Transaction t = jedis.multi();

    String url = tc.getLabel();
    String hashname = termCounterKey(url);

    // si esta página ya fue indexada, borra el hash anterior
    t.del(hashname);

    // para cada término de búsqueda, agrega una entrada en el TermCounter
    // y un nuevo miembro del índice
    for (String term: tc.keySet()) {
        Integer count = tc.get(term);
        t.hset(hashname, term, count.toString());
        t.sadd(urlSetKey(term), url);
    }
    List<Object> res = t.exec();
    return res;
}
\end{verbatim}

Este método usa una \java{Transaction} para recolectar las operaciones y
enviarlos al servidor a la vez, que es mucho más rápido que enviar una
serie de operaciones pequeñas.

\index{Transaction}

El método itera por los término del \java{TermCounter}. Para cada uno

\begin{enumerate}

\item
  Encuentra o crea un \java{TermCounter} en Redis, luego agrega un campo
  para el nuevo término.

\item
  Encuentra o crea un \java{URLSet} en Redis, luego agrega la URL actual.

\end{enumerate}

Si la página ya ha sido indexada, borramos su \java{TermCounter}
antes de agregar los nuevos contenidos..

Eso es todo lo relacionado con la indexación de nuevas páginas.

\index{getCounts}

La segunda parte del ejercicio te pedía escribir \java{getCounts}, que toma
un término de búsqueda y devuelve un mapa de cada URL donde el término
aparece con el número de veces que aparece ahí. Aquí está mi solución:

\begin{verbatim}
    public Map<String, Integer> getCounts(String term) {
        Map<String, Integer> map = new HashMap<String, Integer>();
        Set<String> urls = getURLs(term);
        for (String url: urls) {
            Integer count = getCount(url, term);
            map.put(url, count);
        }
        return map;
    }
\end{verbatim}

\index{helper method}
Este método usa dos métodos auxiliares:

\begin{itemize}

\item
  \java{getURLs} toma un término de búsqueda y devuelve el Set de URLs donde el
  término aparece.

\item
  \java{getCount} toma una URL y un término y devuelve el número de veces que el
  término aparece en la URL dada.

\end{itemize}

Aquí están las implementaciones:

\begin{verbatim}
    public Set<String> getURLs(String term) {
        Set<String> set = jedis.smembers(urlSetKey(term));
        return set;
    }

    public Integer getCount(String url, String term) {
        String redisKey = termCounterKey(url);
        String count = jedis.hget(redisKey, term);
        return new Integer(count);
    }
\end{verbatim}

Debido a la manera en que diseñamos el índice, estos métodos son simples y
eficientes.


\section{Análisis de la búsqueda}
\label{analysis-of-lookup}

Supón que hemos indexado $N$ páginas y descubierto $M$
términos de búsqueda únicos. ¿Cuánto tiempo requerirá la búsqueda de un término
de búsqueda? Piensa en tu respuesta antes de continuar.

\index{análisis}

Para buscar un término de búsqueda, ejecutamos \java{getCounts}, que

\begin{enumerate}

\item
  Crea un mapa.

\item
  Ejecuta \java{getURLs} para obtener un Set de URLs.

\item
  Para cada URL en el Set, ejecuta \java{getCount} y agrega una entrada
  a la \java{HashMap}.

\end{enumerate}

\java{getURLs} toma tiempo proporcinal al número de URLs que contiene
el término de búsqueda. Para términos raros, podría ser un número pequeño,
pero para términos comunes podría ser tan grande como $N$.

Dentro del bucle, ejecutamos \java{getCount}, que encuentra un
\java{TermCounter} en Redis, busca un término y agrega una entrada a un
HashMap. Estos son todas operaciones de tiempo constante, así que la complejidad
global de \java{getCounts} es $O(N)$ en el peor caso. Sin embargo, en la práctica
el tiempo de ejecución es proporcional al número de páginas que contienen
el término, que normalmente es mucho menor que $N$.

\index{tiempo constante}
\index{tiempo lineal}

Este algoritmo es tan eficiente como puede ser, en términos de la
complejidad algorítmica, pero es muy lento porque envía muchas operaciones
pequeñas a Redis. Puedes hacerlo más rápido usando una
\java{Transaction}. Podrías querer hacerlo como ejercicio, o puedes
ver mi solución in \java{RedisIndex.java}.

\index{Transaction}


\section{Análisis de la indexación}
\label{analysis-of-indexing}

Usando las estructuras de datos que diseñamos, ¿cuánto tiempo tomaría
indexar una página? De nuevo, piensa en tu respuesta antes de continuar.

\index{análisis}
\index{árbol DOM}

Para indexar una página, recorremos su árbol DOM, encontramos todos los
objetos \java{TextNode}, y separamos las cadenas en términos de búsqueda.
Todo eso toma tiempo proporcional al número de palabras en la página.

\index{HashMap}

Para cada término, incrementamos un contador en un HashMap, que es una
operación de tiempo constante. Así que hacer el \java{TermCounter} toma
tiempo proporcional al número de palabras en la página.

\index{tiempo lineal}

Agregar el \java{TermCounter} a Redis requiere borrar un
\java{TermCounter}, que es lineal en el número de términos únicos.
Luego para cada término tenemos que

\begin{enumerate}

\item
  Agregar un elemento a un \java{URLSet}, y

\item
  Agrega un elemento a un \java{TermCounter} de Redis.

\end{enumerate}

Ambas son operaciones de tiempo constante, así que el tiempo total para
agregar el \java{TermCounter} es lineal en el número de términos de búsqueda únicos.

\index{tiempo constante}

En resumen, hacer el \java{TermCounter} es proporcional al número
de palabras en la página. Agregar el \java{TermCounter} a Redis
es proporcional al número de términos únicos.

\index{TermCounter}

Dado que el número de palabras en la página usualmente excede el número de
términos de búsqueda únicos, la complejidad global es proporcional al
número de palabras en la página. En teoría una página podría contener
todos los términos de búsqueda en el índice, así que el peor escenario de
desempeño es $O(M)$, pero no esperamos ver el peor escenario en la práctica.

Este análisis sugiere una forma de mejorar el desempeño: deberíamos probablemente
evitar indexar palabras muy comunes. Primero, toman mucho tiempo y espacio,
porque aparecen en cada \java{URLSet} y \java{TermCounter}. Además, no son
muy útiles porque no ayudan a identificar páginas relevantes.

\index{palabras vacías}
\index{stop words}

La mayoría de motores de búsqueda evitan indexar palabras comunes, que se
conocen en este contexto como palabras vacías o stop words 
(\url{http://thinkdast.com/stopword}).


\section{Recorrido de grafos}
\label{graph-traversal}

Si hiciste el ejercicio ``Llegar a la Filosofía'' en el Capítulo~\ref{getphilo}, 
ya tienes un programa que lee una páginas de Wikipedia, encuentra el primer
enlace, usa el enlace para cargar la siguiente páginas y repite el proceso. Este
programa es un tipo especializado de rastreador, pero cuando las personas
dicen ``rastreador Web`` (o Web crawler), usualmente se refieren a un programa que

\begin{itemize}

\item
  Carga una página inicial e indexa los contenidos,

\item
  Encuentra todos los enlaces en la página y agrega las URLs enlazadas a una
  colección y

\item
  Navega por la colección, carga las páginas, las indexa y agrega
  nuevas URLs.

\item
  Si encuentra una URL que ya ha sido indexada, la omite.

\end{itemize}

Puedes pensar en la Web como un grafo
donde cada página es un nodo y cada enlace es una arista dirigida de un nodo
a otro. Si no estás familiarizado con los grafos, puedes leer sobre ellos
en \url{http://thinkdast.com/graph}.

\index{grafo}
\index{recorrido}

Comenzando con un nodo origen, un rastreador recorre este grafo
visitando cada nodo alcanzable una vez.

\index{cola}
\index{pila}
\index{PEPS}
\index{UEPS}

La colección que usamos para guardar las URLs determina qué clase de
recorrido realiza el rastreador:

\begin{itemize}

\item
  Si es una cola primero en entrar, primero en salir (PEPs), el rastreador
  realiza un recorrido en anchura.

\item
  Si es una pila último en entrar, primero en salir (UEPS), el rastreador
  realiza un recorrido en profundidad.

\item
  De forma más general, los elementos en la colección podrían ser priorizados.
  Por ejemplo, podríamos querer dar una prioridad mayor a las páginas que no
  han sido indexadas por un largo tiempo.

\end{itemize}

Puedes leer más sobre el recorrido de grafos en
\url{http://thinkdast.com/graphtrav}.


\section{Ejercicio 12}
\label{exercise12}

\index{WikiCrawler}
\index{JedisIndex}

Ahora es el momento de escribir el rastreador. En el repositorio para este libro,
encontrarás los archivos de código fuente para este ejercicio:

\begin{itemize}

\item \java{WikiCrawler.java}, que contiene código inicial para tu rastreador.

\item \java{WikiCrawlerTest.java}, que contiene código de pruebas para
  \java{WikiCrawler}.

\item \java{JedisIndex.java}, que es mi solución al ejercicio previo.

\end{itemize}

\index{clase auxiliar}

También necesitarás algunas de las clases auxiliares que hemos usado en
ejercicios previos:

\begin{itemize}
\item  \java{JedisMaker.java}
\item  \java{WikiFetcher.java}
\item  \java{TermCounter.java}
\item  \java{WikiNodeIterable.java}
\end{itemize}

Antes de ejecutar \java{JedisMaker}, debes proveer un archivo con información
sobre tu servidor Redis. Si hiciste esto en el ejercicio previo, deberías
estar listo. De lo contrario puedes encontrar instrucciones en la
Sección~\ref{hello-jedis}.

\index{JedisMaker}
\index{Ant}

Ejecuta \java{ant build} para compilar el código fuente, luego ejecuta
\java{ant JedisMaker} para asegurarte que está configurado para conectarse
a tu servidor Redis.

Ahora ejecuta \java{ant WikiCrawlerTest}. Debería
fallar, ¡porque tienes trabajo por hacer!

Aquí está el principio de la clase \java{WikiCrawler} que proveí:

\begin{verbatim}
public class WikiCrawler {

    public final String source;
    private JedisIndex index;
    private Queue<String> queue = new LinkedList<String>();
    final static WikiFetcher wf = new WikiFetcher();

    public WikiCrawler(String source, JedisIndex index) {
        this.source = source;
        this.index = index;
        queue.offer(source);
    }

    public int queueSize() {
        return queue.size();
    }
}
\end{verbatim}

Las variables de instancia son

\begin{itemize}

\item
  \java{source} es la URL desde donde comenzamos el rastreo.

\item
  \java{index} es el \java{JedisIndex} adonde van los resultados.

\item
  \java{queue} es una \java{LinkedList} donde llevamos el control de las URLs
  que hemos descubierto pero aún no hemos indexado.

\item
  \java{wf} es el \java{WikiFetcher} que usaremos para leer e interpretar
  páginas Web.

\end{itemize}

Tu trabajo es llenar \java{crawl}. Aquí está el prototipo:

\index{crawl}

\begin{verbatim}
    public String crawl(boolean testing) throws IOException {}
\end{verbatim}

El parámetro \java{testing} será \java{true} cuando este método sea
llamado desde \java{WikiCrawlerTest} y debería ser \java{false}
en caso contrario.

Cuando \java{testing} es \java{true}, el método \java{crawl} debería:

\begin{itemize}

\item
  Elegir y remover una URL de la cola en orden PEPS.

\item
  Leer los contenidos de la página usando
  \java{WikiFetcher.readWikipedia}, que lee copias en caché de páginas
  incluidad en el repositorio para propósitos de pruebas (para evitar
  problemas si la versión de Wikipedia cambia).

\item
  Debería indexar pagínas sin importar si ya han sido indexadas.

\item
  Debería encontrar todos los enlaces internos en la página y agregarlos a la
  cola en el orden en que aparecen. Los ``enlaces internos'' son enlaces
  a otras páginas de Wikipedia.

\item
  Y debería devolver la URL de la página que indexó.

\end{itemize}

Cuando \java{testing} es \java{false}, este método debería:

\begin{itemize}

\item
  Elegir y remover una URL de la cola en orden PEPS.

\item
  Si la URL ya está indexada, no debería indexarla de nuevo, y
  debería devolver \java{null}.

\item
  De lo contrarior debería leer los contenidos de la página usando
  \java{WikiFetcher.fetchWikipedia}, que lee el contenido actual de
  la Web.

\item
  Luego debería indexar la página, agregar los enlaces a la cola y devolver
  la URL de la página que indexó.

\end{itemize}

\java{WikiCrawlerTest} carga la cola con alrededor de 200 enlaces y luego
invoca a \java{crawl} tres veces. Después de cada invoación, comprueba el
valor de retorno y la nueva longitud de la cola.

Cuando tu rastreador trabaje como se especificó, este test debería pasarse.
¡Buena suerte!



\chapter{Búsqueda booleana}

En este capítulo presento una solución al ejercicio previo. Luego escribirás
código para combinar múltiples resultados de búsqueda y ordenarlos de acuerdo
a su relevancia con respecto a los términos de búsqueda.


\section{Solución del rastreador}
\label{crawler-solution}

Primero, revisemos nuestra solución al ejercicio anterior. Proveí un
boceto de un \java{WikiCrawler}; tu trabajo era llenar \java{crawl}.
Como recordatorio, aquí están los campos de la clase \java{WikiCrawler}:

\index{WikiCrawler}

\begin{verbatim}
public class WikiCrawler {
    // keeps track of where we started
    private final String source;

    // the index where the results go
    private JedisIndex index;

    // queue of URLs to be indexed
    private Queue<String> queue = new LinkedList<String>();

    // fetcher used to get pages from Wikipedia
    final static WikiFetcher wf = new WikiFetcher();
}
\end{verbatim}

Cuando creamos un \java{WikiCrawler}, proveemos \java{source} e
\java{index}. Inicialmente, \java{queue} contiene solo un elemento,
\java{source}.

\index{queue}
\index{LinkedList}

Nota que la implementación de \java{queue} es una
\java{LinkedList}, así que podemos agregar elementos al final --- y 
removerlos del principio --- en tiempo constante. Al asignar un objeto
\java{LinkedList} a una variable de tipo \java{Queue}, nos limitamos a
usuar los métodos en la interfaz \java{Queue}; específicamente,
usaremos \java{offer} para agregar elementos y \java{poll} para
removerlos.

\index{tiempo constante}

Aquí está mi implementación de \java{WikiCrawler.crawl}:

\begin{verbatim}
    public String crawl(boolean testing) throws IOException {
        if (queue.isEmpty()) {
            return null;
        }
        String url = queue.poll();
        System.out.println("Crawling " + url);

        if (testing==false && index.isIndexed(url)) {
            System.out.println("Already indexed.");
            return null;
        }

        Elements paragraphs;
        if (testing) {
            paragraphs = wf.readWikipedia(url);
        } else {
            paragraphs = wf.fetchWikipedia(url);
        }
        index.indexPage(url, paragraphs);
        queueInternalLinks(paragraphs);
        return url;
    }
\end{verbatim}

La mayoría de la complejidad de este método está ahí para hacerlo
más fácil de probar. Aquí está la lógica:

\begin{itemize}

\item
  Si la cola (queue) está vacía, devuelve \java{null} para indicar que
  no indexó una página.

\item
  De lo contrario remueve y guarda la siguiente URL de la cola.

\item
  Si la URL ya ha sido indexada, \java{crawl} no la indexa de nuevo,
  a menos que esté en modo de pruebas.

\item
  A continuación lee los contenidos de la página: si está en modo de
  pruebas, los lee de un archivo; de lo contrario, los lee de la Web.

\item
  Indexa la página.

\item
  Intepreta la página y agrega los enlaces internos a la cola.

\item
  Finalmente, devuelve la URL de la página que indexó.

\end{itemize}

Presenté una implementación de \java{Index.indexPage} en la
Sección~\ref{redis-indexer}. Así que el único método nuevo es
\java{WikiCrawler.queueInternalLinks}.

\index{Index}

Escribí dos versiones de este método con diferentes parámetros: uno
toma un objeto \java{Elements} conteniendo un árbol DOM por párrafo;
el otro toma un objeto \java{Element} que contiene un único párrafo.

\index{Element}

La primera versión solo itera por los párrafos. La segunda versión es
la que hace realmente el trabajo.

\begin{verbatim}
    void queueInternalLinks(Elements paragraphs) {
        for (Element paragraph: paragraphs) {
            queueInternalLinks(paragraph);
        }
    }

    private void queueInternalLinks(Element paragraph) {
        Elements elts = paragraph.select("a[href]");
        for (Element elt: elts) {
            String relURL = elt.attr("href");

            if (relURL.startsWith("/wiki/")) {
                String absURL = elt.attr("abs:href");
                queue.offer(absURL);
            }
        }
    }
\end{verbatim}


Para determinar si un enlace es ``interno,'' comprobamos si la URL
comienza con ``/wiki/''. Esto podría incluir algunas páginas que no queremos
indexa, como meta-páginas sobre Wikipedia. Y podría exluir algunas páginas
que queremos, como enlaces a páginas en idiomas diferentes al inglés. Pero esta
prueba simple es lo suficientemente buena para empezar.

\index{Wikipedia}

Eso es todo. Este ejercició no tenía mucho material nuevo; era mayormente
para combinar todas las piezas del rompecabezas.


\section{Recuperación de información}
\label{information-retrieval}

\index{recuperación de información}

La siguiente fase de este proyecto es implementar una herramienta de búsqueda.
Las partes que necesitaremos incluir son:

\begin{enumerate}

\item
  Una interfaz donde los usuarios puedan proveer términos de búsqueda y ver los resultados.

\item
  Un mecanismo de búsqueda que tome cada término de búsqueda y devuelva las páginas
  que lo contienen.

\item
  Mecanismos para combinar los resultados de búsqueda de múltiples términos de búsqueda.

\item
  Algoritmos para clasificar y ordenar los resultados de búsqueda.

\end{enumerate}

El término general para procesos como este es ``recuperación de información'',
sobre el que puedes más en
\url{http://thinkdast.com/infret}.

En este ejercicio, nos enfocaremos en los pasos 3 y 4. Ya hemos construido una
versión simple del 2. Si estás interesado en construir aplicaciones Web,
podrías considerar trabajar en el paso 1.


\section{Búsqueda boolena}
\label{boolean-search}

\index{búsqueda booleana}

La mayoría de los motores de búsqueda pueden realizar ``búsquedas booleanas'',
lo que significa que puedes combinar los resultados de múltiples términos de
búsqueda usando lógica booleana. Por ejemplo:

\begin{itemize}

\item
  La búsqueda ``java AND programación'' podría devolver sólo las páginas que
  contienen ambos términos de búsqueda: ``java'' y ``programación''.

\item
  ``java OR programación'' podría devolver páginas que contienen cualquiera de
  los términos, pero no necesariamente ambos.

\item
  ``java -indonesia'' podría devolver las páginas que contienen ``java'' y no
  contienen ``indonesia''.

\end{itemize}

Las expresiones como estas que contienen términos de búsqueda y operadores se
conocen como ``consultas''.

\index{consulta}

Cuando se aplican a resultados de búsqueda, los operadores booleanos
\java{AND}, \java{OR}, y \java{-} corresponden a las operaciones de
conjuntos \java{intersection} (intersección), \java{union} (unión), 
y \java{difference} (diferencia). Por ejemplo, supón:

\begin{itemize}

\item
  \java{s1} es el conjunto de páginas que contienen ``java'',

\item
  \java{s2} es el conjunto de páginas que contienen ``programación'', y

\item
  \java{s3} es el conjunto de páginas que contienen ``indonesia''.

\end{itemize}

En ese caso:

\begin{itemize}

\item
  La intersección de \java{s1} y \java{s2} es el conjunto de páginas
  que contienen ``java'' AND ``programación''.

\item
  La unión de \java{s1} y \java{s2} es el conjunto de páginas que
  contienen ``java'' OR ``programación''.

\item
  La diferencia de \java{s1} y \java{s2} es el conjunto de páginas que
  contienen ``java'' y no ``indonesia''.
\end{itemize}

En la siguiente sección escribirás un método para implementar estas operaciones.

\index{intersección}
\index{unión}
\index{diferencia}
\index{operaciones de conjuntos}


\section{Ejercicio 13}
\label{exercise13}

En el repositorio para este libro
encontrarás los archivos de código fuente para este ejercicio:

\begin{itemize}

\item
  \java{WikiSearch.java}, que define un objeto que contiene resultados de
  búsqueda y realiza operaciones en ellos.

\item
  \java{WikiSearchTest.java}, que contiene código de pruebas para
  \java{WikiSearch}.

\item
  \java{Card.java}, que demuestra cómo usar el método \java{sort}
  en \java{java.util.Collections}.

\end{itemize}

También encontrarás algunas de las clases auxiliares que hemos usado en
los ejercicios anteriores.

\index{WikiSearch}
\index{helper class}

Aquí está el principio de la definición de la clase \java{WikiSearch}:

\begin{verbatim}
public class WikiSearch {

    // map from URLs that contain the term(s) to relevance score
    private Map<String, Integer> map;

    public WikiSearch(Map<String, Integer> map) {
        this.map = map;
    }

    public Integer getRelevance(String url) {
        Integer relevance = map.get(url);
        return relevance==null ? 0: relevance;
    }
}
\end{verbatim}

Un objeto \java{WikiSearch} contiene un mapap de URLs con su puntaje de
relevancia. En el contexto de la recuperación de información, un ``puntaje
de relevancia'' que pretende indicar qué tan bien una página satisface las
necesidades de un usuario como se infieren de la consulta. Hay muchas formas de
construir un puntaje de relevancia, pero la mayoría de ellos están basadas en
la ``frecuencia de término'', que es el número de veces que los términos de
búsqueda aparecen en la página. Un puntaje de relevancia común es llamado
TF-IDF, que significa ``frecuencia de término -- frecuencia inversa de
documento''(``term frequency -- inverse document frequency'').  Puedes leer más
sobre al respecto en \url{http://thinkdast.com/tfidf}.

\index{relevancia}
\index{frecuencia de término}
\index{frecuencia inversa de documento}
\index{TF-IDF}

Tendrás la opción de implementar TF-IDF más tarde, pero comenzaremos con algo
incluso más simple, TF:

\begin{itemize}

\item
  Si una consulta contiene un único término de búsqueda, la relevancia de una
  página es su frecuencia de término, es decir, el número de veces que el término
  aparece en la página.

\item
  Para consultas con múltiples términos, la relevancia de una página es la
  suma de las frecuencias de término; es decir, el número total de veces que
  cualquiera de los términos de búsqueda aparece.

\end{itemize}

Ahora estás listo para comenzar el ejercicio.
Ejecuta \java{ant build} para compilar los archivos fuentes, luego ejecuta
\java{ant WikiSearchTest}. Como es usual, debería fallar, porque tienes
trabajo por hacer.

\index{Ant}

En \java{WikiSearch.java}, llena el cuerpo de \java{and},
\java{or}, y \java{minus} para que pasen los tests relevantes. No
tienes que preocuparte por \java{testSort} todavía.

\index{and}
\index{or}
\index{minus}

Puedes ejecutar \java{WikiSearchTest} sin usar Jedis porque no depende
del índice en tu base de datos Redis. Pero si quieres ejecutar una consulta
contra tu índice, tienes que proveer un archivo con información sobre tu
servidor Redis. Mira la Sección~\ref{hello-jedis} para más detalles.

\index{JedisMaker}

Ejecuta \java{ant JedisMaker} para asegurarte que está configurado para
conectarse a tu servidor Redis. Luego ejecuta \java{WikiSearch}, que imprime los
resultados de tres consultas (los términos de búsqueda están en inglés):

\begin{itemize}

\item
  ``java''

\item
  ``programming''

\item
  ``java AND programming''

\end{itemize}

Inicialmente los resultados no estarán en ningun orden particular, porque
\java{WikiSearch.sort} está incompleto.

\index{sort}
\index{Collections}

Llena el cuerpo de \java{sort} para que los resultados se devuelvan en
orden ascendente de relevancia. Sugiero que uses el método \java{sort}
provisto por \java{java.util.Collections}, que ordena cualquier clase de
\java{List}. Puedes leer la documentación en
\url{http://thinkdast.com/collections}.

Hay dos versiones de \java{sort}:

\begin{itemize}

\item
  La versión con un parámetro toma una lista y ordena los elementos usando
  el método \java{compareTo}, así que los elementos tienen que ser
  \java{Comparable}.

\item
  La versión con dos parámetros toma una lista de cualquier tipo de objeto
  y un \java{Comparator}, que es un objeto que provee un método
  \java{compare} que compara elementos.

\end{itemize}

\index{Comparable}
\index{Comparator}

Si no estás familiarizado con las interfaces \java{Comparable} y
\java{Comparator}, las explicaré en la siguiente sección.


\section{{\tt Comparable} y {\tt Comparator}}
\label{comparable-and-comparator}

\index{Card}

El repositorio para este libro incluye \java{Card.java}, que demuestra
dos formas de ordenar una lista de objetos \java{Card}. Aquí está el
principio de la definición de la clase:

\begin{verbatim}
public class Card implements Comparable<Card> {

    private final int rank;
    private final int suit;

    public Card(int rank, int suit) {
        this.rank = rank;
        this.suit = suit;
    }
\end{verbatim}

Un objeto \java{Card} tiene dos campos enteros, \java{rank} y
\java{suit}. \java{Card} implementa
\java{Comparable<Card>}, lo que significa que
provee \java{compareTo}:

\begin{verbatim}
    public int compareTo(Card that) {
        if (this.suit < that.suit) {
            return -1;
        }
        if (this.suit > that.suit) {
            return 1;
        }
        if (this.rank < that.rank) {
            return -1;
        }
        if (this.rank > that.rank) {
            return 1;
        }
        return 0;
    }
\end{verbatim}

\index{compareTo}

La especificación de \java{compareTo} indica que debería devolver
un número negativo si \java{this} se considera menor que
\java{that}, un número positivo si se considera mayor y 0 si
se consideran iguales.

Si usas la versión con un parámetro de \java{Collections.sort}, se
usa el método \java{compareTo} provisto por los elementos para ordenarlos.
Para demostrarlo, podemos hacer una lista de 52 cartas como esta:

\begin{verbatim}
    public static List<Card> makeDeck() {
        List<Card> cards = new ArrayList<Card>();
        for (int suit = 0; suit <= 3; suit++) {
            for (int rank = 1; rank <= 13; rank++) {
                Card card = new Card(rank, suit);
                cards.add(card);
            }
        }
        return cards;
    }
\end{verbatim}

Y ordenarla de esta forma:

\begin{verbatim}
        Collections.sort(cards);
\end{verbatim}

Esta versión de \java{sort} pone los elementos en lo que se llama su
``orden natural'' porque lo determinan los mismos objetos.

\index{orden natural}
\index{Comparator}
\index{compare}

Pero es posible imponer un orden diferente al proveer un objeto
\java{Comparator}. Por ejemplo, el orden natural de los objetos
\java{Card} trate los Ases como las cartas de menor rango, pero en algunos
juegos tienen el rango más alto. Podemos definir un \java{Comparator}
que considere a los ``Ases con un rango alto'', como este:

\begin{verbatim}
        Comparator<Card> comparator = new Comparator<Card>() {
            @Override
            public int compare(Card card1, Card card2) {
                if (card1.getSuit() < card2.getSuit()) {
                    return -1;
                }
                if (card1.getSuit() > card2.getSuit()) {
                    return 1;
                }
                int rank1 = getRankAceHigh(card1);
                int rank2 = getRankAceHigh(card2);

                if (rank1 < rank2) {
                    return -1;
                }
                if (rank1 > rank2) {
                    return 1;
                }
                return 0;
            }

            private int getRankAceHigh(Card card) {
                int rank = card.getRank();
                if (rank == 1) {
                    return 14;
                } else {
                    return rank;
                }
            }
        };
\end{verbatim}

Este código define una clase anónima que implementa \java{compare},
como se requiere. Luego crea una intancia de la clase recién definida
e innombrada. Si no estás familiarizado con las clases anónimas en
java, puedes leer sobre ellas en \url{http://thinkdast.com/anonclass}.

\index{clase anónima}

Al usar este \java{Comparator}, podemos invocar \java{sort} así:

\begin{verbatim}
        Collections.sort(cards, comparator);
\end{verbatim}

En este ordenamiento, el As de Espadas (Ace of Spades) es considerado como
el de mayor rango en el mazo; el dos de Tréboles (two of Clubs) es el menor.

\index{ordenamiento}

El código en esta sección está en \java{Card.java} si quieres experiementar
con él. Como un ejercicio podrías querer escribir un comparador que ordene
por \java{rank} primero y luego por \java{suit}, así todos loa Ases
estarían juntos y todos los dos, etc.


\section{Extensiones}
\label{extensions}

\index{TF-IDF}
\index{relevancia}
\index{snippet}
\index{Heroku}

Si logras que funcione una versión básica de este ejercicio, podrías querer
trabajar en estos ejercicios opcionales:

\begin{itemize}

\item Lee sobre TF-IDF en \url{http://thinkdast.com/tfidf} e
  impleméntalo. Podrías tener que modificar \java{JavaIndex} para
  calcular frecuencias de documento; es decir, el número total de veces
  que cada término aparece en todas las páginas en el índice.

\item Para consultas con más de un término de búsqueda, la relevancia total para
  cada página es actualmente la suma de la relevancia para cada término. Piensa
  sobre cuándo esta versión simple podría no funcionar bien, y prueba algunas
  alternativas.

\item Construye una interfaz de usuario que permita a los usuarios ingresar
  consultas con operadores booleanos. Interpreta las consultas, genera los
  resultados, luego ordénalos por relevacia y muestra las URLs con los puntajes
  más altos. Considera generar ``fragmentos'' que muestren dónde aparecieron los
  términos de búsqueda en la página. Si quieres hacer una aplicación Web para
  tu interfaz de usuario, considera usar Heroku como una opción simple para
  desarrollar y desplegar aplicaciones Web usando Java.  Ver
  \url{http://thinkdast.com/heroku}.

\end{itemize}



\chapter{Ordenamiento}

Los departamentos de ciencias de la computación tienen una obsesión poco
saludable con los algoritmos de ordenamiento. Con base en la cantida de
tiempo que los estudiantes de CC dedican al tema, podrías pensar que la
elección de un algoritmo de ordenamiento es la piedra fundamental de la
ingeniería de software moderna. Por supuesto, la realidad que los
desarrolladores de software pueden pasar años, o incluso carreras, sin
pensar sobre cómo funciona el ordenamiento. Para casi todas las aplicaciones,
ellos utilizan cualquier algoritmo de propósito general que provea el lenguaje
o las bibliotecas que usan. Y usualmente eso está bien.

\index{ordenamiento}

Así que si te saltas este capítulo y no aprendes nada sobre algoritmos de
ordenamiento todavía puedes ser un excelente desarrollador. Pero hay unas
cuantas razones por las que podrías querer hacerlo de todas maneras:

\begin{enumerate}

\item
  Aunque hay muchos algoritmos de propósito general que funcionan bien para la
  vasta mayoría de aplicaciones, hay dos algoritmos de propósito espcial sobre
  los que podrías querer saber: ordenamiento radix y el ordenamiento por
  montículos acotado.

\item
  Un algoritmo de ordenamiento, el ordenamiento por mezcla, es un excelente
  ejemplo para la enseñanza porque demuesra una estrategia importante y
  útil para el diseño de algoritmos, llamada ``divide-conquista-pega''. También,
  cuando analizamos su rendimiento, aprenderás sobre una orden de crecimiento
  que no hemos visto antes, {\bf linearítmica}. Finalmente, algunos de los
  algoritmos más ampliamente utilizados son híbridos que incluyen elementos
  del ordenamiento por mezcla.

\item
  Una razón más para aprender sobre algoritmos de ordenamiento es que a los
  entrevistadores técnicos les fascina preguntar sobre ellos. Si quieres que
  te contraten, ayuda si puedes demostrar formación cultural en CC.

\end{enumerate}

Así, en este capítulo analizaremos el ordenamiento por inserción, implementarás
el ordenamiento por mezcla, te contaré sobre el ordenamiento radix y escribirás
una versión simple del ordenamiento por montículos acotado.

\index{divide-conquista-pega}
\index{tiempo linearítmico}


\section{Ordenamiento por inserción}
\label{insertion-sort}

Comenzaremos con el ordenamiento por inserción,mayormente porque es sencillo de
describir e implementar. No es muy eficiente, pero tiene algunas características
que lo redimen, como veremos.

\index{insertion sort}

En lugar de explicar el algoritmo aquí, sugiero que leas la página
de Wikipedia sobre el ordenamiento por inserción en
\url{http://thinkdast.com/insertsort}, que incluye
pseudocódigo y ejemplos animados. Regresa cuando hayas captado la idea
general.

Aquí está una implementación del ordenamiento por inserción en Java:

\begin{verbatim}
public class ListSorter<T> {

    public void insertionSort(List<T> list, Comparator<T> comparator) {

        for (int i=1; i < list.size(); i++) {
            T elt_i = list.get(i);
            int j = i;
            while (j > 0) {
                T elt_j = list.get(j-1);
                if (comparator.compare(elt_i, elt_j) >= 0) {
                    break;
                }
                list.set(j, elt_j);
                j--;
            }
            list.set(j, elt_i);
        }
    }
}
\end{verbatim}

Defino una clase, \java{ListSorter}, como un contenedor para algoritmos
de ordenamiento. Al usar el parámetro de tipo, \java{T}, podemos escribir
métodos que funcionen en listas que contengan cualquier tipo de objeto.

\index{ListSorter}
\index{parámetro de tipo}

\java{insertionSort} toma dos parámetros, una \java{List} de cualquier tipo
y un \java{Comparator} que sabe cómo comparar dos objetos de tipo \java{T}.  
Éste ordena la lista ``en sitio'', lo que significa que modifica la lista
existente y no tiene que reservar nuevo espacio.

\index{List}

El siguiente ejemplo muestra cómo llamar a este método con una \java{List}
de objetos \java{Integer}:

\begin{verbatim}
        List<Integer> list = new ArrayList<Integer>(
            Arrays.asList(3, 5, 1, 4, 2));

        Comparator<Integer> comparator = new Comparator<Integer>() {
            @Override
            public int compare(Integer elt1, Integer elt2) {
                return elt1.compareTo(elt2);
            }
        };

        ListSorter<Integer> sorter = new ListSorter<Integer>();
        sorter.insertionSort(list, comparator);
        System.out.println(list);
\end{verbatim}

\java{insertionSort} tienen dos bucles anidados, así que podrías asumir que
su tiempo de ejecución es cuadrático. En este caso, eso es correcto, pero
antes de saltar a esa conclusión, tienes que comprobar que el número de
veces que se ejecuta cada bucle es proporcional a $n$, el tamaño
del arreglo.

\index{tiempo lineal}

El bucle externo itera desde 1 hasta \java{list.size()}, así que es lineal 
con respecto al tamaño de la lista, $n$.
El bucle interno itera desde \java{i} hasta 0, así que también es lineal con
respecto a $n$.  Por lo tanto, el número total de veces que el bucle interno
se ejecuta es cuadrático.

\index{tiempo cuadrático}

Si no estás seguro de ello, aquí está el argumento:

\begin{itemize}

\item
  La primera vez, $i=1$ y el bucle interior se ejecuta al menos
  una vez.

\item
  La segunda vez, $i=2$ y el bucle interior se ejecua al menos dos veces.

\item
  La última vez, $i=n-1$ y el bucle interior se ejecuta al menos
  $n-1$ veces.

\end{itemize}

Así que el número total de veces que el bucle interior se ejecuta es la
suma de la serie $1, 2, \ldots , n-1$, que es $n (n-1) / 2$. Y el término
principal de esa expresión (el que tiene el exponente más alto) es
$n^2$.

\index{tiempo lineal}

En el peor escenario, el ordenamiento por inserción es cuadrático. Sin embargo:

\begin{enumerate}

\item
  Si los elementos ya están ordenados, o casi, el ordenamiento por inserción
  es lineal. Específicamente, si cada elemento no está a más de $k$
  posiciones de donde debería estar, el bucle interior nunca se ejecuta más
  de $k$ veces, y el tiempo de ejecución total es $O(kn)$.

\item
  Porque la implementación es simple, la sobrecarga es menor, es decir,
  aunque el tiempo de ejecución es $a n^2$, el coeficiente del término
  principal, $a$, probablemente es pequeño.

\end{enumerate}

Así que si sabemos que el arreglo está casi ordenado, o no es muy grande,
el ordenamiento por inserción podría ser una buena elección. Pero para
arreglos más grandes, podemos hacerlo mejor. De hecho, mucho mejor.


\section{Ejercicio 14}
\label{exercise14}

El ordenamiento por mezcla (mergesort) es uno de varios algoritmos de ordenamiento cuyo
tiempo de ejecución es mejor que el cuadrático. De nuevo, en lugar de explicar
el algoritmo aquí, sugiero que leas sobre él en Wikipedia en
\url{http://thinkdast.com/mergesort}.  Una vez captes la idea, regresa y puedes
probar su comprensión escribiendo una implementación.

\index{ordenamiento por mezcla}
\index{tiempo cuadrático}

En el repositorio para este libro, encontrarás los archivos de código fuente para
este ejercicio:

\begin{itemize}

\item
  \java{ListSorter.java}

\item
  \java{ListSorterTest.java}

\end{itemize}

Ejecuta \java{ant build} para compilar los archivos de código fuente, luego ejecuta
\java{ant ListSorterTest}. Como es lo usual, debería fallar,
porque tienes trabajo por hacer.

\index{Ant}
\index{ListSorter}

En \java{ListSorter.java}, he provisto un boceto de dos métodos,
\java{mergeSortInPlace} y \java{mergeSort}:

\begin{verbatim}
    public void mergeSortInPlace(List<T> list, Comparator<T> comparator) {
        List<T> sorted = mergeSortHelper(list, comparator);
        list.clear();
        list.addAll(sorted);
    }

    private List<T> mergeSort(List<T> list, Comparator<T> comparator) {
       // TODO: fill this in!
       return null;
    }
\end{verbatim}

Estos dos métodos hacen lo mismo pero proveen interfaces diferentes.
\java{mergeSort} toma una lista y devuelve una nueva lista con los mismos
elementos ordenados de forma ascendente. \java{mergeSortInPlace} es un
método \java{void} que modifica una lista existente.

\index{mergeSort}

Tu trabajo es llenar \java{mergeSort}. Antes de escribir una versión
completamente recursiva del ordenamiento por mezcla, comienza con algo
como esto:

\begin{enumerate}

\item
  Divide la lista en dos.

\item
  Ordena (sort) las mitades usando \java{Collections.sort} o
  \java{insertionSort}.

\item
  Combina (merge) las mitades ordenadas en una lista completa ordenada.

\end{enumerate}

Esto te dará una oportunidad de depurar el código para combinar sin lidiar
con la complejidad de un método recursivo.

\index{caso base}
\index{recursión}

A continuación, agrega un caso base (er
\url{http://thinkdast.com/basecase}). Si te dan una lista
con solo un elemento, puedes devolverla inmediatamente, dado que
ya está ordenada, en cierto modo. O si la longitud de la lista está
por debajo de algún umbral, podrías ordenarla usando \java{Collections.sort}
o \java{insertionSort}. Prueba el caso base antes de continuar.

Finalmente, modifica tu solución para que realice dos llamadas recursivas
para ordenar las mitades del arreglo. Cuando logres que funcionen, deberían
pasar \java{testMergeSort} y \java{testMergeSortInPlace}.


\section{Análisis del ordenamiento por mezcla}
\label{analysis-of-merge-sort}

\index{análisis}

Para clasificar el tiempo de ejecución del ordenamiento por mezcla, sirve
pensar en términos de niveles de recursión y de cuánto trabajo se realiza
en cada nivel. Supón que comenzamos con una lista que contiene $n$ elementos. 
Aquí están los pasos del algoritmo:

\begin{enumerate}

\item
  Crea dos nuevos arreglos y copia la mitad de los elementos en cada uno.

\item
  Ordena las dos mitades.

\item
  Combina las mitades.

\end{enumerate}

La figura~\ref{fig-sort1}
muestra estos pasos.

\begin{figure}
\centering
\includegraphics[height=2.5in]{figs/merge_sort1.pdf}
\caption{Representación del ordenamiento por mezcla mostrando un nivel de recursión.}
\label{fig-sort1}
\end{figure}

\index{tiempo lineal}

El primer paso copia cada uno de los elementos una vez, así que es lineal. El
tercer paso también copia cada elemento una vez, así que también es lineal.
Ahora necesitamos determinar la complejidad del paso 2. Para hacerlo, ayuda
una mirada a una parte diferente de cálculo, que muestra los niveles de la
recursión, como en la figura~\ref{fig-sort2}.

\begin{figure}
\centering
\includegraphics[height=2in]{figs/merge_sort2.pdf}
\caption{Representación del ordenamiento por mezcla mostrando todos los niveles de recursión.}
\label{fig-sort2}
\end{figure}

En el nivel superior, tenemos $1$ lista con $n$ elementos. 
Por simplicidad, asumamos que $n$ es una potencia de 2.
En el siguiente nivel hay $2$ listas con $n/2$ elementos.
Luego $4$ listas con $n/4$ elementos, y así sucesivamente
hasta que tenemos $n$ con $1$ elemento.

En cada nivel tenemos un total de $n$ elementos. Hacia abajo, tenemos
que dividir (split) los arreglos por la mitad, lo que toma tiempo
proporcional a $n$ en cada nivel. Hacia arriba, tenemos que combinar (merge)
un total de $n$ elementos, lo que también es lineal.

Si el número de niveles es $h$, la cantidad total de trabajo para el
algoritmo es $O(nh)$. Así que, ¿cuántos niveles hay? Hay dos formas de
pensar sobre eso:

\begin{enumerate}

\item
  ¿Cuántas veces tenemos que dividir $n$ por la mitad para obtener 1?

\item
   O, ¿cuántas veces tenemos que duplicar $1$ para obtener $n$?

\end{enumerate}

Otra forma de formular la segunda pregunta es ``¿Qué potencia de 2 es
$n$?''

$2^h = n$

Aplicando $\log_2$ a ambos lados se tiene:

$h = \log_2 n$

Así que el tiempo total es $O(n \log n)$. No me preocupé por escribir la
base del logaritmo porque logaritmos con diferentes bases difieren por un
factor constante, así que todos los logaritmos están en la misma orden de
crecimiento.

\index{logaritmo}
\index{tiempo linearítmico}
\index{n log n}

Los algoritmos en $O(n \log n)$ a veces son llamados
``linearítmicos'', pero la mayoría de personas solo dicen ``n log n''.

\index{ordenamiento por comparación}

Resulta que $O(n \log n)$ es el límite inferior teórico para los
algoritmos de ordenamiento que trabajan comparando elementos entre sí. Eso
significa que no hay un ``ordenamiento por comparación'' cuya orden de
crrecimiento sea mejor que $n \log n$.  Véase \url{http://thinkdast.com/compsort}.

Pero como veremos en la siguiente sección, ¡hay ordenamientos de no
comparación que toman tiempo lineal!

\index{tiempo lineal}


\section{Ordenamiento radix}
\label{radix-sort}

\index{ordenamiento radix}
\index{Obama, Barack}
\index{Schmidt, Eric}
\index{Google}
\index{ordenamiento de burbuja}

Durante la Campaña Presidencial de Estados Unidos en 2008, al candidato
Barack Obama se le pidió que realizara un análisis de algoritmos
improvisado cuando visitó Google. El director ejecutivo Eric Schmidt en
broma le preguntó sobre ``la forma más eficiente de ordenar un millón
de enteros de 32 bits.'' Al parecer a Obama lo habían puesto sobre aviso,
porque rápidamente replicó, ``Creo que el ordenamiento de burbuja sería
la forma equivocada de hacerlo.'' Puedes ver el video en
\url{http://thinkdast.com/obama}.

Obama tenía razón. el ordenamiento de burbuja es conceptualmente más
sencillo pero su tiempo de ejecución es cuadrático; e incluso entre los
algoritmos de ordenamiento cuadráticos, su desemepeño no es muy bueno.
Véase \url{http://thinkdast.com/bubble}.

\index{tiempo cuadrático}

La respuesta que Schmidt probablemente buscaba es ``ordenamiento radix'', que es
un algoritmo de ordenamiento de {\bf no comparación} que funciona si el tamaño de
los elementos está acotado, como un entero de 32-bits o una cadena de 20 caracteres.

\index{ordenamiento de no comparación}

Para ver cómo funciona esto, imagina que tienes una pila de fichas donde
cada ficha contiene una palabra de tres letras. Así es como podrías ordenar
las fichas:

\begin{enumerate}

\item
  Realiza un pase por las fichas y divídelas en contenedores con base en
  la primer letra. Así que las palabras que comienzan con \java{a} deberían
  ir en un contenedor, seguidas por las palabras que comienzan con \java{b},
  y así sucesivamente.

\item
  Divide cada contenedor de nuevo con base en la segunda letra. Así que las
  palabras que comienzan con \java{aa} irían juntas, seguidas por las palabras
  que comienzan con \java{ab}, y así. Por supeuesto, no todos los contenedores
  se llenarían, pero eso está bien.

\item
  Divide cada contenedor de nuevo con base en la tercera letra.

\end{enumerate}

Llegados a este punto cada contenedor contiene un elemento y los contenedores
están ordenados de forma ascendente. La figura~\ref{fig-sort3} muestra un
ejemplo con palabras de tres letras.

\begin{figure}
\centering
\includegraphics[height=2.0in]{figs/radix_sort1.pdf}
\caption{Ejemplo del ordenamiento radix con palabras de tres letras.}
\label{fig-sort3}
\end{figure}

La fila superior muestra las palabras desordenadas. La segunda fila muestra
cómo quedan los contenedores tras el primer pase. Las palabras en cada
contenedor comienzan con la misma letra.

Tras el segundo pase, las palabras en cada contenedor comienzan con las mismas
dos leras. Tras el tercer pase, solo puede haber una palabra en cada contenedor,
y los contenedores están en orden.

Durante cada pase, iteramos por los elementos y los agregamos a
contenedores. Siempre que los contenedores permitan agregar en
tiempo constante, cada pase es lineal.

\index{tiempo constante}
\index{tiempo lineal}

El número de pases, al que llamaré $w$, dependen del ``ancho'' (``width'')
de las palabras, pero no depende del número de palabras, $n$. Así que
el orden de crecimiento es $O(wn)$, que es lineal con respecto a $n$.

Hay muchas variantes del ordenamiento radix, y muchas formas de implementar
cada una. Puedes leer más sobre ellas en
\url{http://thinkdast.com/radix}. Como un ejercicio opcional, 
considera escribir una versión del ordenamiento radix.


\section{Ordenamiento por montículos}
\label{heap-sort}

\index{ordenamiento por montículos}
\index{montículo acotado}

Además del ordenamiento radix, que se aplica cuando las cosas que quieres
ordenar tienen un tamaño fijo, hay otro ordenamiento de propósitos
especiales con el que podrías encontrarte: ordenamiento por montículos
acotados. El ordenamiento por montículos acotados es útil si estás trabajando
con un conjunto de datos muy grande y quieres reportar el ``Top 10'' o el
``Top k'' para algún valor $k$ mucho más pequeño que $n$.

Por ejemplo, supón que estás monitoreando un servicio Web que maneja
mil millones de transacciones por día. Al final de cada día, quieres
reportar las $k$ transacciones más grandes (o las más lentas, o cualquier
otro superlativo). Una opción es guardar todas las transacciones, ordenarlas
al final del día, y seleccionar el top $k$. Eso tomaría tiempo proporcional a
$n \log n$, y sería muy lento porque probablemente mil millones de transacciones
no quepan en la memoria de un programa. Tendríamos que usar un algoritmo de
memoria externa. Puedes leer sobre el ordenamiento externo en
\url{http://thinkdast.com/extsort}.

\index{algoritmo de memoria externa}
\index{ordenamiento externo}

Al usar un montículo acotado, ¡podemos obtener mejores resultados! Así
es como procederemos:

\begin{enumerate}

\item
  Explicaré el ordenamiento por montículos (no acotado)

\item
  Lo implementarás.

\item
  Explicaré el ordenamiento por montículos acotado y lo analizaré.

\end{enumerate}

\index{montículo}
\index{árbol binario de búsqueda}
\index{ABB}

Para entender el ordenamiento por montículos, tienes que entender qué es un
montículo, que es una estructura de datos similar a un árbol binario de
búsqueda (ABB). Aquí están las diferencias:

\begin{itemize}

\item
  En un ABB, cada nodo, \java{x}, tiene la ``propiedad ABB'': todos los nodos
  en el subárbol izquierdo de \java{x} son menores que \java{x} y todos
  los nodos en el subárbol derecho son mayores que \java{x}.

\item
  En un montículo, cada nodo, \java{x}, tiene la ``propiedad montículo'': todos
  los nodos en ámbos subárboles de \java{x} son mayores que \java{x}.

\item
  Los montículos son como ABBs balanceados; cuando agregas o remueves
  elementos, ellas realizan algún trabajo adicional para volver a balancear
  el árbol. Como resultado, pueden ser implementadas de forma eficiente
  usando un arrreglo de elementos.

\end{itemize}

El elemento más pequeño en un montículo siempre está en la raíz, así que
podemos encontrarlo en tiempo constante. Agregar y remover elementos de
un montículo toma tiempo proporcional a la altura del árbol $h$. Y como
el montículo siempre está balanceado, $h$ es proporcional a $\log n$.
Puedes leer más sobre los montículos en \url{http://thinkdast.com/heap}.

\index{propiedad montículo}
\index{tiempo constante}
\index{tiempo logarítmico}
\index{PriorityQueue}
\index{offer}
\index{poll}
\index{Queue}

La \java{PriorityQueue} de Java se implementa usando un montículo.
\java{PriorityQueue} provee los métodos especificados en la
interfaz \java{Queue}, incluyendo \java{offer} y \java{poll}:

\begin{itemize}

\item
  \java{offer}: Agrega un elemento a la cola, actualizando el montículo para
  que cada nodo tenga la ``propiedad montículo''. Toma un tiempo de $\log n$.

\item
  \java{poll}: Remueve el elemento más pequeño en la cola de la raíz y actualiza
  el montículo. Toma un tiempo de $\log n$.

\end{itemize}

Dada una \java{PriorityQueue}, puedes ordenar fácilmente una colección de
$n$ elementos de la siguiente manera:

\begin{enumerate}

\item
  Agrega todos los elementos de la colección a una \java{PriorityQueue} usando
  \java{offer}.

\item
  Remueve los elementos de la cola usando \java{poll} y agrégalos a
  una \java{List}.

\end{enumerate}

Porque \java{poll} devuelve el elemento más pequeño que queda en la
cola, los elementos se agregan a la \java{List} en orden ascendente.
A esta forma de ordenar se la llama {\bf ordenamiento por montículos}
(véase \url{http://thinkdast.com/heapsort}).

\index{ordenamiento por montículos}
\index{linearítmico}
\index{n log n}

Agregar $n$ elementos a la cola toma un tiempo de $n \log n$. Al
igual que remover $n$ elementos. Así que el tiempo de ejecución
para el ordenamiento por montículos es $O(n \log n)$.

\index{ListSorter}

En el repositorio para este libro, en \java{ListSorter.java} encontrarás
el boceto de un método llamado \java{heapSort}. Llénalo y luego ejecuta
\java{ant ListSorterTest} para confirmar que funciona.


\section{Montículo acotado}
\label{bounded-heap}

\index{montículo acotado}

Un montículo acotado es un montículo que está limitado a contener
como máximo $k$ elementos. Si tienes $n$ elementos, puedes llevar el
control de los $k$ elementos mayores así:

Inicialmente, el montículo está vacío.  Para cada elemento, \java{x}:

\begin{itemize}

\item
  Caso 1: Si el montículo no está lleno, agrega a \java{x} al montículo.

\item
  Caso 2: Si el montículo está lleno, compara \java{x} con el elemento
  \emph{menor} del montículo. Si \java{x} es más pequeño, no
  puede ser uno de los $k$ elementos mayores, así que puedes descartarlo.

\item
  Caso 3: Si el montículo está lleno y \java{x} es mayor que el elemento
  menor en el montículo, remueve el elemento menor del montículo y
  agrega a \java{x}.

\end{itemize}

\index{k elementos mayores}

Al usar un montículo con el elemento menor en la parte superior, podemos
llevar el control de los $k$ elementos mayores. Analicemos el desempeño
de este algoritmo. Para cada elemento, realizamos una de las siguientes
operaciones:

\begin{itemize}

\item
  Caso 1: Agregar un elemento al montículo es $O(\log k)$.

\item
  Caso 2: Encontrar el elemento más pequeño en el montículo es $O(1)$.

\item
  Caso 3: Remover el elemento más pequeño es $O(\log k)$. Agregar
  \java{x} también es $O(\log k)$.

\end{itemize}

En el peor escenario, si los elementos aparecen en orden ascendente, siempre
ejecutamos el caso 3. De ser así, el tiempo total para procesar $n$
elementos es $O(n \log k)$, que es lineal con respecto a $n$.

\index{tiempo lineal}

En \java{ListSorter.java} encontrarás el boceto de un método llamado
\java{topK} que toma una \java{List}, un \java{Comparator}, y un
entero $k$. Debería devolver los $k$ elementos mayores en la \java{List}
en orden ascendente. Llénalo y luego ejecuta \java{ant ListSorterTest}
para confirmar que funciona.

\index{Comparator}


\section{Complejidad espacial}
\label{space-complexity}

\index{complejidad espacial}
\index{análisis}

Hasta este momento hemos hablando mucho sobre análisis del tiempo de
ejecución, pero para muchos algoritmos también nos preocupa el espacio.
Por ejemplo, una de las desventajas del ordenamiento por mezcla es que
copia todos los datos. En nuestra implementación, la cantidad total de
espacio que se reserva es $O(n \log n)$. Con una implementación un poco
más ingeniosa, puedes reducir el requerimiento de espacio a $O(n)$.

Por el contrario, el ordenamiento por inserción no copia los datos porque
ordena los elementos en sitio. Usa variables temporales para comparar dos
elementos a la vez y usa unas cuantas variables locales adicionales. Pero
su uso del espacio no depende de $n$.

Nuestra implementación del ordenamiento por montículos crea una nueva
\java{PriorityQueue} para guardar los elementos, así que es espacio es
$O(n)$; pero si se te permitiera ordenar la lista en sitio, podrías
ejecutar el ordenamiento por montículos con un espacio de $O(1)$.

Uno de los beneficios del algoritmo de ordenamiento por montículos acotados
que acabas de implementar es que sólo necesita espacio proporcional a $k$
(el número de elemento que queremos conservar), y $k$ a menudo es mucho
menor que $n$.

Los desarrolladores de software tienden a prestar más atención al tiempo de
ejecución que al espacio, y para muchas aplicaciones, eso es lo apropiado. Pero
para conjuntos de datos grandes, el espacio puede ser igual de importante o
incluso más. Por ejemplo:

\begin{enumerate}

\item Si un conjunto de datos no cabe en la memoria de un programa, el tiempo
  de ejecución muchas veces se incrementa dramáticamente, o puede que ni
  siquiera se ejecute. Si eliges un algoritmo que necesita menos espacio,
  y eso hace posible que el cálculo quepa en la memoria, podría ejecutarse
  mucho más rápido. En el mismo sentido, un programa que usa menos espacio
  podría hacer mejor uso de la caché de la CPU y ejecutarse más rápido
  (véase \url{http://thinkdast.com/cache}).

\item En un servidor que ejecuta muchos programas al mismo tiempo, si puedes
  reducir el espacio que cada programa necesita, podrías ser capaz de
  ejecutar más programas en el mismo servidor, lo que reduce los costos de
  hardware y energía.

\end{enumerate}

Así que esas son algunas razones por las que deberías saber al menos un
poquito sobre las necesidades de espacio de los algoritmos.

\index{caché}
\index{servidor}


\backmatter
\printindex

%\cleardoublepage

\end{document}
